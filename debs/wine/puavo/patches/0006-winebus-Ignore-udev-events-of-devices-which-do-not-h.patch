From dccb6e0b3dbe8dcbd301a2c1ffecfe4092da6cfc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Tuomas=20R=C3=A4s=C3=A4nen?= <tuomas.rasanen@opinsys.fi>
Date: Fri, 22 Mar 2024 11:41:25 +0200
Subject: [PATCH 6/6] winebus: Ignore udev events of devices which do not have
 devnodes.

Udev monitor monitors the whole input subsystem, but not all devices
in the input subsystem have devnodes associated to them.

This commit makes the event processing ignore such devices.

All device handling assumes devices have devnodes, so here we just
simply ignore all devices which do not have one.

Previously, udev bus thread aborted when an event for a device without
a devnode was processed:

  10111.330:0068:0084:trace:hid:process_monitor_event Received action "remove" for udev device (null)
  10111.330:0068:0084:warn:hid:bus_main_thread L"UDEV" bus wait returned status 0xc0000005

Just plugging in and out a normal mouse was enough cause this.

This was because root input devices (which do not have devnodes) were
handled too and find_device_from_devnode() choked on NULL argument.

(cherry picked from commit ef58b8c770023c13652954103b2a0b117e2deb94)
---
 dlls/winebus.sys/bus_udev.c | 28 ++++++++++++++++++++--------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 419de2e7af3..2cd995a4178 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1710,26 +1710,38 @@ static void process_monitor_event(struct udev_monitor *monitor)
 {
     struct base_device *impl;
     struct udev_device *dev;
-    const char *action;
+    const char *action, *devnode, *syspath;
 
     dev = udev_monitor_receive_device(monitor);
     if (!dev)
     {
-        FIXME("Failed to get device that has changed\n");
+        ERR("Failed to get device that has changed\n");
         return;
     }
 
     action = udev_device_get_action(dev);
-    TRACE("Received action %s for udev device %s\n", debugstr_a(action),
-          debugstr_a(udev_device_get_devnode(dev)));
-
-    if (!action)
-        WARN("No action received\n");
+    syspath = udev_device_get_syspath(dev);
+    devnode = udev_device_get_devnode(dev);
+    TRACE("Received action %s for udev device %s (%p) devnode %s\n",
+          debugstr_a(action), debugstr_a(syspath), dev, debugstr_a(devnode));
+
+    if (!syspath)
+        ERR("udev device %p does not have syspath!\n", dev);
+    else if (!action)
+        ERR("event for udev device %s does not have any action!\n", syspath);
+    else if (!devnode)
+    {
+        /* Pretty normal case, not all devices have associated
+         * devnodes. For example root input devices do not, but
+         * related/child mouse and event devices do.
+         */
+        TRACE("udev device %s does not have devnode, ignoring\n", syspath);
+    }
     else if (strcmp(action, "remove"))
         udev_add_device(dev, -1);
     else
     {
-        impl = find_device_from_devnode(udev_device_get_devnode(dev));
+        impl = find_device_from_devnode(devnode);
         if (impl) bus_event_queue_device_removed(&event_queue, &impl->unix_device);
         else WARN("failed to find device for udev device %p\n", dev);
     }
-- 
2.39.2

