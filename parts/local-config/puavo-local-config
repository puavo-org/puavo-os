#!/usr/bin/ruby1.9.1

# puavo-local-config configures system according to admin user preferences.
# See puavo-local-config-ui for the user interface.  puavo-local-config
# reads a configuration file ("/state/etc/puavo/local/config.json"
# by default) that contains user preferences, and applies those to the
# system depending on given option arguments.  Run
# "puavo-local-config --help" for information on command arguments.
# Most wanted functionality must be explicitly requested with command
# arguments, but puavo-local-config also intends to prepare the system for
# configuration (by puavo-local-config-ui).

require 'etc'
require 'fileutils'
require 'getoptlong'
require 'json'

Ltspadmins_group_id = 3000

def print_help()
  puts <<-EOF
puavo-local-config [OPTIONS]

-c, --config-path    set configuration file path
-h, --help           show help

    --admins         configure admins
    --grub-default   configure grub default
    --local-users    configure local users

    --install-pkgs   ["all" | a list of software separated with comma]
    --setup-pkgs     ["all" | a list of software separated with comma]
  EOF
end

def conf_version_1_ok?(conf)
  is_boolean = lambda { |v| v.kind_of?(TrueClass) || v.kind_of?(FalseClass) }

  conf['allow_logins_for'].kind_of?(Array) \
    && conf['allow_logins_for'].map { |s| s.kind_of?(String) }.all? \
    && is_boolean.call(conf['allow_remoteadmins']) \
    && conf['licenses'].kind_of?(Hash) \
    && conf['licenses'].map do |k, v|
                              k.kind_of?(String) && is_boolean.call(v)
                            end \
                       .all? \
    && conf['local_users'].kind_of?(Hash) \
    && conf['local_users'].map do |login, u|
                                 login.kind_of?(String) \
                                   && u.kind_of?(Hash) \
                                   && u['hashed_password'].kind_of?(String) \
                                   && u['name'].kind_of?(String) \
                                   && u['uid'].kind_of?(Integer) \
                                   && is_boolean.call(u['enabled'])
                               end \
                          .all?
end

def ensure_conf_sanity(conf, config_path)
  move_conf = lambda {
                warn 'Moving configuration file, because it is messed up'
                FileUtils.mv(config_path,
                             "#{ config_path }.backup-#{ Time.now().to_i }")
              }

  if conf.nil? then
    if File.exists?(config_path) then
      move_conf.call()
    end
    return nil
  end

  # this might include migration code if version should be greater

  if conf['version'] == 1 && conf_version_1_ok?(conf) then
    return conf
  else
    move_conf.call()
    return nil
  end
end

def search_and_replace_line(file, re, new_line)
  File.open(file, 'r') do |inputf|
    output_lines = []

    have_match = false

    inputf.flock(File::LOCK_EX);

    input_lines = inputf.read.split("\n")
    input_lines.each do |line|
      match = line.match(re)
      if match then
        have_match = true
        output_lines.push(new_line) if new_line
      else
        output_lines.push(line)
      end
    end

    if !have_match then
      output_lines.push(new_line) if new_line
    end

    output = output_lines.map { |s| "#{ s }\n" }.join

    tmpfile = "#{ file }.plctmp"
    File.open(tmpfile, 'w', 0600) { |outputf| outputf.write(output) }
    FileUtils.chmod(inputf.stat.mode, tmpfile)
    FileUtils.chown(inputf.stat.uid, inputf.stat.gid, tmpfile)
    File.rename(tmpfile, file)
  end
end

def configure_admins()
  device = JSON.parse( IO.read('/state/etc/puavo/device.json') )
  admin  = device['primary_user'] || ''

  kernel_cmdline = IO.read('/proc/cmdline')

  new_line = "puavolocaladmins:x:#{ Ltspadmins_group_id }:#{ admin }"
  search_and_replace_line('/etc/group',
                         /^puavolocaladmins:/,
                         new_line)

  File.open('/etc/sudoers.d/puavolocaladmins.pcltmp', 'w') do |f|
    if superlaptop_mode? then
      f.write("%puavolocaladmins ALL=(ALL) ALL\n")
    end
    f.write('%puavolocaladmins ALL=(ALL) NOPASSWD: ' \
            + "/usr/sbin/puavo-local-config\n")
  end
  File.rename('/etc/sudoers.d/puavolocaladmins.pcltmp',
              '/etc/sudoers.d/puavolocaladmins')
end

def configure_local_users(conf)
  return if conf.nil?

  uid_min, uid_max = 3001, 3999
  group_id = Etc.getgrnam('users').gid

  problems = false

  conf['local_users'].each do |login, user|
    if user['uid'] < uid_min then
      warn "uid is below uid_min for '#{ login }'"
      problems = true
      next
    end
    if user['uid'] > uid_max
      warn "uid is over uid_max for '#{ login }'"
      problems = true
      next
    end

    home = "/home/#{ login }"
    passwd_line \
      = user['enabled'] \
          ? ("#{ login }:x:#{ user['uid'] }:#{ group_id }" \
               + ":#{ user['name'] },,,:#{ home }:/bin/bash")
          : nil

    search_and_replace_line('/etc/passwd',
			    /^#{ login }:/,
			    passwd_line)

    shadow_line = user['enabled'] \
                    ? "#{ login }:#{ user['hashed_password'] }:::::::" \
                    : nil

    search_and_replace_line('/etc/shadow',
                            /^#{ login }:/,
                            shadow_line)
  end

  raise 'Problems in configure_local_users' if problems
end

def configure_grub_default()
  kernel_cmdline = IO.read('/proc/cmdline')
  match = kernel_cmdline.match(/loop=(.*?)\.img/)
  raise 'Could not figure out loop= device' unless match
  loop_img = "#{ match[1] }.img"

  this_ltspimage_name = IO.read('/etc/ltsp/this_ltspimage_name').chomp

  choice_types = {
    '/ltsp.img'        => 'DEFAULT',
    '/ltsp-backup.img' => 'BACKUP',
  }

  choice_type = choice_types[loop_img]
  description \
    = choice_type \
        ? "#{ choice_type } - (lvm/puavo-images)/#{ this_ltspimage_name } (#{ loop_img })" \
        : "OTHER (#{ loop_img })"

  if superlaptop_mode?
    description = "*SUPERLAPTOP* #{ description }"
  end

  system('/usr/bin/grub-editenv',
         '/images/boot/grub/grubenv',
         'set',
         %Q{default=#{ description }}) \
    or raise 'Problem in updating grub environment'
end

def install_pkgs(pkg_list)
  %w(download install).each do |action|
    restricted_package_tool(action, *pkg_list) \
      or raise "Problem in downloading: #{ pkg_list.join(', ') }"
  end
end

def parse_pkg_list(pkg_list)
  pkg_list == 'all' \
    ? Dir.glob('/usr/share/puavo-ltsp-client/restricted-packages/*') \
         .map { |s| File.basename(s) } \
    : pkg_list.split(',')
end

def restricted_package_tool(*args)
  system('/usr/sbin/puavo-restricted-package-tool', *args)
end

def setup_pkgs(conf, pkg_list)
  return if conf.nil?

  to_install, to_uninstall = pkg_list.partition { |pkg| conf['licenses'][pkg] }

  if !to_install.empty? then
    restricted_package_tool('install', *to_install) \
      or raise 'Problem in installing packages'
  end

  if !to_uninstall.empty? then
    restricted_package_tool('uninstall', *to_uninstall) \
      or raise 'Problem in uninstalling packages'
  end
end

def superlaptop_mode?
  kernel_cmdline = IO.read('/proc/cmdline')
  superlaptop_mode_re \
    = /puavo.image.overlay=default puavo.local.enable_superusers=true/
  kernel_cmdline.match(superlaptop_mode_re) ? true : false
end

config_path = '/state/etc/puavo/local/config.json'

apply_configs    = []
install_pkg_list = []
setup_pkg_list   = []

begin
  opts = GetoptLong.new(
    [ '--config-path',   '-c', GetoptLong::REQUIRED_ARGUMENT, ],
    [ '--help',          '-h', GetoptLong::NO_ARGUMENT,       ],

    [ '--admins',              GetoptLong::NO_ARGUMENT,       ],
    [ '--grub-default',        GetoptLong::NO_ARGUMENT,       ],
    [ '--local-users',         GetoptLong::NO_ARGUMENT,       ],
    [ '--install-pkgs',        GetoptLong::REQUIRED_ARGUMENT, ],
    [ '--setup-pkgs',          GetoptLong::REQUIRED_ARGUMENT, ],
  )

  opts.each do |opt, arg|
    case opt
      when '--config-path'
	config_path = arg
      when '--help'
	print_help()
	exit(0)
      when '--admins', '--grub-default', '--local-users'
	apply_configs.push(opt)
      when '--install-pkgs'
	apply_configs.push(opt)
	install_pkg_list = parse_pkg_list(arg)
      when '--setup-pkgs'
	apply_configs.push(opt)
	setup_pkg_list = parse_pkg_list(arg)
    end
  end

rescue GetoptLong::InvalidOption => e
  print_help()
  exit(1)
end

# we prepare the standard config path directory
config_path_dir = File.dirname(config_path)
FileUtils.mkdir_p(config_path_dir)
FileUtils.chmod(02770, config_path_dir)
FileUtils.chown(0, Ltspadmins_group_id, config_path_dir)

begin
  conf = JSON.parse( IO.read(config_path) )
rescue Errno::ENOENT
  conf = nil
rescue Exception => e
  warn "Could not read and interpret #{ config_path }: #{ e.message }"
  conf = nil
end

conf = ensure_conf_sanity(conf, config_path)

dispatch_table = {
  '--admins'       => lambda { configure_admins()               },
  '--grub-default' => lambda { configure_grub_default()         },
  '--local-users'  => lambda { configure_local_users(conf)      },
  '--install-pkgs' => lambda { install_pkgs(install_pkg_list)   },
  '--setup-pkgs'   => lambda { setup_pkgs(conf, setup_pkg_list) },
}

exit_code = 0

apply_configs.each do |part|
  begin
    dispatch_table[part].call()
  rescue Exception => e
    warn "Could not handle #{ part }: #{ e.message } / #{ e.backtrace }"
    exit_code = 1
  end
end

exit(exit_code)
