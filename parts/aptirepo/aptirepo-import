#!/bin/sh
# aptirepo - simple APT repository tool
# Copyright (C) 2013 Opinsys Oy
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

set -eu

. aptirepo-env

. "${APTIREPO_LIBDIR}/common.sh"

import_changes()
{
    local changes_file changes_dir lines source_name distribution archs

    changes_file=$1

    changes_dir=$(dirname "${changes_file}")
    if [ $? -ne 0 ]; then
        echo "failed to obtain the directory path of '${changes_file}'" >&2
        return 1
    fi

    changes_dir=$(readlink -e "${changes_dir}")
    if [ $? -ne 0 ]; then
        echo "failed to canonicalize the directory path '${changes_dir}'" >&2
        return 1
    fi

    lines=$(parse_multiline "${changes_file}" "Files")
    if [ $? -ne 0 ]; then
        echo "failed to parse 'Files' from '${changes_file}'" >&2
        return 1
    fi
    if [ -z "${lines}" ]; then
        echo "control file field 'Files' not found from '${changes_file}'" >&2
        return 1
    fi

    source_name=$(parse_simple "${changes_file}" "Source")
    if [ $? -ne 0 ]; then
        echo "failed to parse 'Source' from '${changes_file}'" >&2
        return 1
    fi
    if [ -z "${source_name}" ]; then
        echo "control file field 'Source' not found from '${changes_file}'" >&2
        return 1
    fi

    distribution=$(parse_simple "${changes_file}" "Distribution")
    if [ $? -ne 0 ]; then
        echo "failed to parse 'Distribution' from '${changes_file}'" >&2
        return 1
    fi
    if [ -z "${distribution}" ]; then
        echo "control file field 'Distribution' not found from '${changes_file}'" >&2
        return 1
    fi

    archs=$(parse_simple "${changes_file}" "Architecture")
    if [ $? -ne 0 ]; then
        echo "failed to parse 'Architecture' from '${changes_file}'" >&2
        return 1
    fi
    if [ -z "${archs}" ]; then
        echo "control file field 'Architecture' not found from '${changes_file}'" >&2
        return 1
    fi

    echo "${lines}" | while read md5 size section priority filename; do

        filepath="${changes_dir}/${filename}"
        echo "${md5}  ${filepath}" | md5sum --quiet --strict --check || {
            echo "failed to check the md5 checksum of '${filepath}'" >&2
            exit 1
        }

        component=$(echo "${section}" | sed -r -n 's|^(.*)/.*$|\1|p')
        if [ $? -ne 0 ]; then
            echo "failed to parse section '${section}'" >&2
            exit 1
        fi
        if [ -z "${component}" ]; then
            echo "'${filename}': component guessed as 'main'" >&2
            component="main"
        fi

        distsuffix=''
        if [ -n "${APTIREPO_BRANCH}" ]; then
            distsuffix="-${APTIREPO_BRANCH}"
        fi

        dstdir="pool/${distribution}${distsuffix}/${component}/$(echo ${source_name} | head -c1)/${source_name}"

        mkdir -p "${dstdir}" || {
            echo "failed to create the pool destination directory '${dstdir}'" >&2
            exit 1
        }

        cp -a -n -t "${dstdir}" "${filepath}" || {
            echo "failed to copy '${filepath}' to the pool directory '${dstdir}'" >&2
            rmdir -p --ignore-fail-on-non-empty "${dstdir}"
            exit 1
        }

        for arch in $archs; do
            if [ "${arch}"  != "source" ]; then
                arch="binary-${arch}"
            fi
            mkdir -p "dists/${distribution}${distsuffix}/${component}/${arch}"
        done

    done || return 1
}

APTIREPO_ROOT=${APTIREPO_ROOT:-.}

cd "${APTIREPO_ROOT}"

if [ ! -d .aptirepo ]; then
    echo "'$(pwd)' is not an aptirepo repository" >&2
    exit 1
fi

APTIREPO_BRANCH=''

while getopts "b:" flag; do
    case $flag in
        b)
            if [ -n "${APTIREPO_BRANCH}" ]; then
                echo "-b can be used only once" >&2
                exit 1
            fi
            # TODO: validate input
            APTIREPO_BRANCH="${OPTARG}"
            ;;
        ?)
            exit 1
            ;;
        *)
            echo "getopts failed catastrophically" >&2
            exit 1
            ;;
  esac
done

shift $((OPTIND-1))

if [ $# -ne 1 ]; then
    echo "wrong number of arguments" >&2
    echo "Usage: $(basename $0) [-b BRANCH] FILE" >&2
    exit 1
fi

case "$1" in
    *.changes)
        (
            flock -n 9 || {
                echo "failed to lock the repository" >&2
                exit 1
            }
            import_changes $1 || {
                echo "failed to import '$1'" >&2
                exit 1
            }
        ) 9>.aptirepo/lock
        ;;
    *)
        echo "ignoring '$1'" >&2
        exit 1
        ;;
esac

aptirepo-update
