#!/usr/bin/env python3

# pylint: disable=invalid-name

"""
Puavo Display Manager
"""

# Standard library imports
import argparse
import collections
import dataclasses
import logging
import logging.handlers
import os
import subprocess
import signal
import sys
import typing

# Third-party imports
# pylint: disable=wrong-import-position
import gi  # type: ignore[import]

gi.require_version("GUdev", "1.0")

from gi.repository import GUdev, GLib  # type: ignore[import]

# Internal imports
import puavodisplays.mutter
import puavodisplays.puavoconf
import puavodisplays.xrandr

_LOGGER = logging.getLogger("puavo-display-manager")


def _call_run_xrandr() -> None:
    _LOGGER.info("Calling run-xrandr...")
    subprocess.check_call(["/usr/lib/puavo-displays/run-xrandr"])


def _get_npixels(mode: puavodisplays.xrandr.Mode) -> int:
    return mode.resolution_x * mode.resolution_y


def _is_worse_than(
    output1: puavodisplays.xrandr.Output, output2: puavodisplays.xrandr.Output
) -> bool:
    return _get_npixels(output1.modes[0]) < _get_npixels(output2.modes[0])


def _get_worst_connected_output_and_others(
    connected_outputs: typing.List[puavodisplays.xrandr.Output],
) -> typing.Tuple[
    puavodisplays.xrandr.Output,
    typing.List[puavodisplays.xrandr.Output],
]:
    worst_connected_output = connected_outputs[0]
    other_connected_outputs: typing.List[puavodisplays.xrandr.Output] = []
    for connected_output in connected_outputs[1:]:
        if _is_worse_than(connected_output, worst_connected_output):
            other_connected_outputs.append(worst_connected_output)
            worst_connected_output = connected_output
        else:
            other_connected_outputs.append(connected_output)
    return worst_connected_output, other_connected_outputs


def _to_xrandr_mode_str(mode: puavodisplays.xrandr.Mode) -> str:
    return f"{mode.resolution_x}x{mode.resolution_y}"


def _ensure_no_black_borders() -> None:
    _LOGGER.info("Ensuring none of the connected displays have black borders...")
    connected_outputs = [
        o
        for o in puavodisplays.xrandr.get_prop().values()
        if o.state == puavodisplays.xrandr.OutputState.CONNECTED
    ]

    if len(connected_outputs) < 1:
        _LOGGER.info("No connected displays.")
        return

    (
        worst_connected_output,
        other_connected_outputs,
    ) = _get_worst_connected_output_and_others(connected_outputs)

    xrandr_args = []
    if len(connected_outputs) == 1:
        _LOGGER.info("Clearing transformations from the only connected display.")
        xrandr_args.append("--output")
        xrandr_args.append(worst_connected_output.name)
        xrandr_args.append("--transform")
        xrandr_args.append("none")
    else:
        xrandr_args.append("--output")
        xrandr_args.append(worst_connected_output.name)
        xrandr_args.append("--mode")
        xrandr_args.append(_to_xrandr_mode_str(worst_connected_output.modes[0]))
        xrandr_args.append("--transform")
        xrandr_args.append("none")

        for other_connected_output in other_connected_outputs:
            if other_connected_output.current_mode is None:
                # Something strange, all connected outputs should have
                # current mode.
                _LOGGER.error(
                    "Connected output %r does not have current mode!",
                    other_connected_output.name,
                )
                continue

            xrandr_args.append("--output")
            xrandr_args.append(other_connected_output.name)
            xrandr_args.append("--same-as")
            xrandr_args.append(worst_connected_output.name)
            xrandr_args.append("--mode")
            xrandr_args.append(_to_xrandr_mode_str(other_connected_output.current_mode))
            xrandr_args.append("--scale-from")
            xrandr_args.append(_to_xrandr_mode_str(worst_connected_output.modes[0]))

    _LOGGER.info("Calling xrandr: %r", xrandr_args)
    puavodisplays.xrandr.call_xrandr(xrandr_args)


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description=__doc__,
    )
    parser.add_argument(
        "--log-level",
        choices=logging.getLevelNamesMapping().keys(),
        default=logging.getLevelName(logging.INFO),
    )
    parser.add_argument(
        "--ignore-mutter",
        action="store_true",
        default=False,
        help="manage displays when Mutter is configured to be in charge",
    )
    parser.add_argument(
        "--best",
        action="store_true",
        default=False,
        help="do everything to setup the best display configuration",
    )

    return parser.parse_args()


def _int_10base(v: str) -> int:
    return int(v, 10)


def _set_max_bpc() -> None:
    desired_max_bpc = puavodisplays.puavoconf.get_as(
        "puavo.displays.max_bpc", _int_10base
    )

    _LOGGER.info("Setting max bpc of all display outputs to %d.", desired_max_bpc)
    puavodisplays.xrandr.set_max_bpc_of_all_display_outputs(
        desired_max_bpc, logger=_LOGGER
    )


def _check_required_env_vars() -> None:
    for env_var in ("DISPLAY", "XAUTHORITY"):
        if env_var not in os.environ:
            raise RuntimeError("Required environment variable is not set", env_var)


def _is_mutter_in_charge() -> bool:
    return not set(os.environ["MUTTER_ALLOW_CONFIGURATION"].split(",")).isdisjoint(
        {"default", "user"}
    )


def _does_puavo_have_xrandr_configurations() -> bool:
    # Comparing values to knownx defaults. If values differ, it means
    # "Puavo has some xrandr configurations".
    if puavodisplays.puavoconf.get("puavo.xrandr.apply_presets") != "":
        return True

    if puavodisplays.puavoconf.get("puavo.xrandr.args") != "[]":
        return True

    if puavodisplays.puavoconf.get("puavo.xrandr.extra_modes") != "auto":
        return True

    return False


# Models the runtime setup Puavo Display Manager has to deal with.
Setup = collections.namedtuple(
    "Setup",
    [
        "args_best",
        "args_ignore_mutter",
        "mutter_in_charge",
        "puavo_has_confs",
    ],
)


# This is called on start up and whenever DRM device configuration
# changes (after Udev DRM stabilization timeout).
def _manage(setup: Setup) -> None:
    _LOGGER.info("Starting to manage displays.")
    # fmt: off
    # pylint: disable=line-too-long
    # All actions Puavo Display Manager takes are determined by the runtime setup. (2**4 definitions; 4 boolean flags)
    action_map: typing.Dict[Setup, typing.List[typing.Callable[[], None]]] = {
        # Hotplug case:
        Setup(args_best=True  , args_ignore_mutter=False , mutter_in_charge=True  , puavo_has_confs=False) : [_set_max_bpc],
        Setup(args_best=True  , args_ignore_mutter=False , mutter_in_charge=True  , puavo_has_confs=True)  : [_set_max_bpc],
        Setup(args_best=True  , args_ignore_mutter=False , mutter_in_charge=False , puavo_has_confs=False) : [_set_max_bpc, _ensure_no_black_borders],
        Setup(args_best=True  , args_ignore_mutter=False , mutter_in_charge=False , puavo_has_confs=True)  : [_set_max_bpc, _call_run_xrandr],

        # Session start case:
        Setup(args_best=False , args_ignore_mutter=True  , mutter_in_charge=True  , puavo_has_confs=False) : [],
        Setup(args_best=False , args_ignore_mutter=True  , mutter_in_charge=True  , puavo_has_confs=True)  : [_set_max_bpc, _call_run_xrandr],
        Setup(args_best=False , args_ignore_mutter=True  , mutter_in_charge=False , puavo_has_confs=False) : [],
        Setup(args_best=False , args_ignore_mutter=True  , mutter_in_charge=False , puavo_has_confs=True)  : [_set_max_bpc, _call_run_xrandr],

        # Greeter start case:
        Setup(args_best=True  , args_ignore_mutter=True  , mutter_in_charge=True  , puavo_has_confs=False) : [_set_max_bpc, _ensure_no_black_borders],
        Setup(args_best=True  , args_ignore_mutter=True  , mutter_in_charge=True  , puavo_has_confs=True)  : [_set_max_bpc, _call_run_xrandr],
        Setup(args_best=True  , args_ignore_mutter=True  , mutter_in_charge=False , puavo_has_confs=False) : [_set_max_bpc, _ensure_no_black_borders],
        Setup(args_best=True  , args_ignore_mutter=True  , mutter_in_charge=False , puavo_has_confs=True)  : [_set_max_bpc, _call_run_xrandr],

        # Default case:
        Setup(args_best=False , args_ignore_mutter=False , mutter_in_charge=True  , puavo_has_confs=False) : [],
        Setup(args_best=False , args_ignore_mutter=False , mutter_in_charge=True  , puavo_has_confs=True)  : [],
        Setup(args_best=False , args_ignore_mutter=False , mutter_in_charge=False , puavo_has_confs=False) : [],
        Setup(args_best=False , args_ignore_mutter=False , mutter_in_charge=False , puavo_has_confs=True)  : [_set_max_bpc, _call_run_xrandr],
    }
    # pylint: enable=line-too-long
    # fmt: on

    for action in action_map[setup]:
        action()

    _LOGGER.info(
        "I have done everything I can for now. I'll sleep until something happens again."
    )


# Udev events are bursty in nature; there are multiple consecutive
# events for example when a DRM device is added. This timer is reset
# on every DRM event and display management takes place after events
# have "stabilized".
_UEVENT_DRM_STABILIZATION_TIMEOUT_MS = 1000


@dataclasses.dataclass(kw_only=True)
class _DRMConnector:
    name: str
    sysfs_path: str
    enabled: bool
    connected: bool
    edid: typing.Optional[bytes] = None

    def __str__(self) -> str:
        return self.name


def _update_drm_connector_edid(drm_connector: _DRMConnector) -> bool:
    new_edid: typing.Optional[bytes] = None

    try:
        with open(os.path.join(drm_connector.sysfs_path, "edid"), "rb") as edid_file:
            new_edid = edid_file.read()
    except FileNotFoundError:
        new_edid = None

    if drm_connector.edid != new_edid:
        drm_connector.edid = new_edid
        return True

    return False


def _update_drm_connector(drm_connector: _DRMConnector) -> bool:
    changed: bool = False

    with open(
        os.path.join(drm_connector.sysfs_path, "status"), encoding="utf-8"
    ) as status_file:
        new_connected: bool = status_file.read() == "connected"

    with open(
        os.path.join(drm_connector.sysfs_path, "enabled"), encoding="utf-8"
    ) as enabled_file:
        new_enabled: bool = enabled_file.read() == "enabled"

    if drm_connector.connected != new_connected:
        drm_connector.connected = new_connected
        changed = True

    if drm_connector.enabled != new_enabled:
        drm_connector.enabled = new_enabled
        changed = True

    changed |= _update_drm_connector_edid(drm_connector)

    return changed


def _gudev_device_to_drm_connector(device: GUdev.Device) -> _DRMConnector:
    drm_connector = _DRMConnector(
        name=device.get_name(),
        sysfs_path=device.get_sysfs_path(),
        enabled=device.get_sysfs_attr("enabled") == "enabled",
        connected=device.get_sysfs_attr("status") == "connected",
    )

    _update_drm_connector_edid(drm_connector)

    return drm_connector


class _PuavoDisplayManager:  # pylint: disable=too-few-public-methods
    def __init__(self, setup: Setup):
        self.__setup = setup
        self.__drm_connectors: typing.Dict[str, _DRMConnector] = {}
        self.__drm_stabilization_timer_id = None

        self.__gudev_client = GUdev.Client.new(["drm"])
        self.__gudev_client.connect("uevent", self.__on_uevent)

    def __update_drm_connectors(self) -> bool:
        changed: bool = False
        for drm_connector in self.__drm_connectors.values():
            changed |= _update_drm_connector(drm_connector)
            _LOGGER.info("Updated DRM connector: %s", drm_connector)
        return changed

    def __reset_drm_stabilization_timer(self) -> None:
        if self.__drm_stabilization_timer_id is not None:
            GLib.source_remove(self.__drm_stabilization_timer_id)
        self.__drm_stabilization_timer_id = GLib.timeout_add(
            _UEVENT_DRM_STABILIZATION_TIMEOUT_MS,
            self.__on_drm_stabilization_timeout,
        )

    def __on_drm_stabilization_timeout(self) -> None:
        self.__drm_stabilization_timer_id = None
        self.__update_drm_connectors()
        _LOGGER.info("DRM configuration has changed.")
        _manage(self.__setup)

    def __remove_gudev_device_drm_connector(self, device: GUdev.Device) -> bool:
        if device.get_devtype() != "drm_connector":
            return False

        drm_connector = self.__drm_connectors.pop(device.get_name())
        _LOGGER.info("Removed the following DRM connector: %s", drm_connector)

        return True

    def __add_gudev_device_drm_connector(self, device: GUdev.Device) -> bool:
        if device.get_devtype() != "drm_connector":
            return False

        drm_connector = _gudev_device_to_drm_connector(device)
        if drm_connector.name in self.__drm_connectors:
            _LOGGER.warning("DRM connector was already added: %s", drm_connector)
            return False

        self.__drm_connectors[drm_connector.name] = drm_connector
        _LOGGER.info("Added the following DRM connector: %s", drm_connector)

        return True

    def on_start(self) -> None:
        """Called from GLib mainloop when it has started."""

        _LOGGER.info("Entered the wonderful world of displays.")
        for device in self.__gudev_client.query_by_subsystem("drm"):
            self.__add_gudev_device_drm_connector(device)

        self.__update_drm_connectors()

        puavodisplays.mutter.reset_scale()
        _LOGGER.info("Reset Mutter scaling.")

        _manage(self.__setup)

    def __on_uevent(self, _: GUdev.Client, action: str, device: GUdev.Device) -> None:
        if device.get_subsystem() != "drm":
            return

        self.__reset_drm_stabilization_timer()

        _LOGGER.info(
            "Udev event from drm subsystem: devtype=%r action=%r name=%r",
            device.get_devtype(),
            action,
            device.get_name(),
        )

        if action == "remove":
            self.__remove_gudev_device_drm_connector(device)
            return

        if action == "add":
            self.__add_gudev_device_drm_connector(device)
            return


def _main() -> int:
    logging_formatter = logging.Formatter(
        fmt="%(name)s: %(levelname)s %(asctime)s %(message)s",
        datefmt="%Y-%m-%dT%H:%M:%S%z",
    )

    logging_handler_stderr = logging.StreamHandler(sys.stderr)
    logging_handler_stderr.setFormatter(logging_formatter)
    _LOGGER.addHandler(logging_handler_stderr)

    logging_handler_syslog = logging.handlers.SysLogHandler("/dev/log")
    logging_handler_syslog.setFormatter(logging_formatter)
    _LOGGER.addHandler(logging_handler_syslog)

    args = _parse_args()

    _LOGGER.setLevel(args.log_level)

    _LOGGER.info("Starting the journey...")

    _check_required_env_vars()

    setup = Setup(
        args_best=args.best,
        args_ignore_mutter=args.ignore_mutter,
        mutter_in_charge=_is_mutter_in_charge(),
        puavo_has_confs=_does_puavo_have_xrandr_configurations(),
    )
    _LOGGER.info("%s", setup)

    pdm = _PuavoDisplayManager(setup)

    GLib.timeout_add(0, pdm.on_start)

    mainloop = GLib.MainLoop()

    def sighandler(signum: int, _: object) -> None:  # pylint: disable=unused-argument
        _LOGGER.info("Signal %d caught, quitting the mainloop...", signum)
        mainloop.quit()

    signal.signal(signal.SIGINT, sighandler)
    signal.signal(signal.SIGTERM, sighandler)
    signal.signal(signal.SIGHUP, sighandler)
    signal.signal(signal.SIGABRT, sighandler)
    signal.signal(signal.SIGALRM, sighandler)
    signal.signal(signal.SIGUSR1, sighandler)
    signal.signal(signal.SIGUSR2, sighandler)
    mainloop.run()

    return 0


if __name__ == "__main__":
    try:
        sys.exit(_main())
    finally:
        _LOGGER.info("Bye.")
