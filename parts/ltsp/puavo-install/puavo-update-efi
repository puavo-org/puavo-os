#!/bin/sh

set -eu

# XXX this should log something
# XXX this should probably use some kind of a lock

pue_mountdir=$(mktemp -d /tmp/puavo-update-efi.XXXXXX)

get_system_images() {
  local img
  (
    cd /images
    for img in *.img; do
      test "$img" = 'ltsp.img'        && continue
      test "$img" = 'ltsp-backup.img' && continue
      printf "%s\n" "$img"
    done
  )
}

install_all_ukis_for_image() {
  local all_status uki_partition image kernel
  uki_partition=$1
  image=$2

  all_status=0

  mkdir -p "${pue_mountdir}/image" || return 1
  mount -o ro "/images/${image}" "${pue_mountdir}/image" || return 1
  for vmlinuz_path in ${pue_mountdir}/image/boot/vmlinuz-*; do
    test ! -h "$vmlinuz_path" || continue
    vmlinuz=${vmlinuz_path##*/}
    install_uki_for_image "$vmlinuz" "$image" || all_status=1
  done
  umount "${pue_mountdir}/image" || return 1

  return $all_status
}

cleanup_unused_ukis() {
  local imgdir imgdir_path system_images
  system_images=$1

  for imgdir_path in ${pue_mountdir}/efi/EFI/PuavoOS/*; do
    test -d "$imgdir_path" || continue
    rm -f ${imgdir_path}/*.tmp
    img=${imgdir_path##*/}
    if printf "%s\n" "$system_images" | grep -Fq "$img"; then
      # this is something we want to keep
      continue
    fi
    rm -rf "$imgdir_path"
  done
}

install_ukis() {
  local uki_partition efi_status system_images
  uki_partition=$1
  system_images=$2

  efi_status=0

  mkdir -p "${pue_mountdir}/efi" || return 1
  mount "$uki_partition" "${pue_mountdir}/efi" || return 1

  cleanup_unused_ukis "$system_images" || return 1

  for img in $system_images; do
    install_all_ukis_for_image "$uki_partition" "$img" || efi_status=1
  done

  umount "${pue_mountdir}/efi" || return 1

  return $efi_status
}

install_uki_for_image() {
  local image initrd target_dir tmp_target_dir vmlinuz

  vmlinuz=$1
  image=$2

  target_dir="${pue_mountdir}/efi/EFI/PuavoOS/${image}"

  if [ -e "$target_dir" ]; then
    # nothing to do
    # XXX BUT what if a newer version of puavo-update-efi does something
    # XXX differently and we should recreate the files here?
    return 0
  fi

  initrd="initrd.img-${vmlinuz#vmlinuz-}"
  tmp_target_dir="${target_dir}.tmp"

  mkdir -p "$tmp_target_dir" || return 1

  # XXX cmdline depends on context (for example bootserver vs laptop)
  if ! /usr/lib/systemd/ukify build \
    --linux "${pue_mountdir}/image/boot/${vmlinuz}" \
    --initrd "${pue_mountdir}/image/boot/${initrd}" \
    --cmdline 'ro init=/sbin/init-puavo quiet loglevel=3 splash puavo.hosttype=laptop root=/dev/mapper/puavo-images loop=/ltsp.img puavo.image.path=/ltsp.img' \
    --output "${tmp_target_dir}/${vmlinuz}.unsigned.efi" >/dev/null; then
      rm -rf "$tmp_target_dir"
      return 1
  fi

  sync || true
  if ! mv "$tmp_target_dir" "$target_dir" 2>/dev/null; then
    rm -rf "$tmp_target_dir"
    return 1
  fi
  sync || true

  return 0
}

status=0

system_images=$(get_system_images)

# XXX should this support other VG targets than "puavo"?  (puavoinstaller?)
vgname='puavo'

uki_partitions=$(/usr/lib/puavo-ltsp-install/puavo-list-install-devices \
                   --list-uki-partitions --vgname "$vgname")

uki_installed=false
for uki_partition in $uki_partitions; do
  install_ukis "$uki_partition" "$system_images" || status=1
  uki_installed=true
done

if ! $uki_installed; then
  # if we have not installed UKI kernels (nothing to install),
  # return 2 as a special code
  status=2
fi

rm --one-file-system -rf "$pue_mountdir" || true

exit $status
