#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import copy
import datetime
import errno
import fcntl
import filecmp
import gettext
import gi
import glob
import hashlib
import json
import os
import re
import requests
import shutil
import signal
import subprocess
import sys
import syslog
import threading
import time
import zipfile

gi.require_version('AyatanaAppIndicator3', '0.1')
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')

from gi.repository import AyatanaAppIndicator3
from gi.repository import Gdk
from gi.repository import Gio
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gtk
from gi.repository import Notify

from requests.auth import HTTPBasicAuth

gettext.bindtextdomain('puavo-ers-applet', '/usr/share/locale')
gettext.textdomain('puavo-ers-applet')
_tr = gettext.gettext

KTP_JAKO_DIR            = os.path.join(os.environ['HOME'], 'ktp-jako')
ANSWERS_DIR             = os.path.join(KTP_JAKO_DIR, 'Vastaukset')
COMM_DIR                = os.path.join(KTP_JAKO_DIR, '.opinsys')
EXAMS_ARCHIVE_DIR       = os.path.join(KTP_JAKO_DIR, 'Arkisto')
EXAMS_DIR               = os.path.join(KTP_JAKO_DIR, '.exams')
EXAMS_JSON_FILE         = os.path.join(KTP_JAKO_DIR, '.exams.json')
EXAMS_UPCOMING_DIR      = os.path.join(KTP_JAKO_DIR, 'Tulevat')


exam_scheduler_lock = threading.Lock()
current_exams_set = None
current_zip_name = None


def puavoconf_get(puavoconf_key):
  return subprocess.check_output([ 'puavo-conf', puavoconf_key ]).rstrip() \
                   .decode('utf-8')


def rm_f(path, with_logging=True):
  try:
    os.unlink(path)
    if with_logging:
      syslog.syslog(syslog.LOG_INFO, 'removed %s' % path)
  except OSError as e:
    if e.errno != errno.ENOENT:
      raise e


class CurrentZipNotReady(Exception):
  pass

class ExamSchedulerNotActive(Exception):
  pass


class PuavoExamServer:
  def __init__(self):
    self.exam_server_name = puavoconf_get('puavo.abitti.exam_server')

    with open('/etc/puavo/domain') as f:
      self.domain = f.read().rstrip()
    with open('/etc/puavo/hostname') as f:
      self.hostname = f.read().rstrip()
    with open('/etc/puavo/id') as f:
      self.id = f.read().rstrip()
    with open('/etc/puavo/ldap/dn') as f:
      self.ldap_dn = f.read().rstrip()
    with open('/etc/puavo/ldap/password') as f:
      self.ldap_password = f.read().rstrip()


  def get(self, path, params={}):
    uri = 'https://%s%s' % (self.exam_server_name, path)

    req_params = params
    req_params.update({
                        'domain':   self.domain,
                        'hostname': self.hostname,
                        'id':       self.id,
                      })

    try:
      response = requests.get(uri,
                              auth=HTTPBasicAuth(self.ldap_dn,
                                                 self.ldap_password),
                              params=req_params,
                              timeout=20)
      if response.status_code != requests.codes.ok:
        syslog.syslog(syslog.LOG_ERR,
          'error on GET request to %s: code=%s' % (uri, response.status_code))
    except Exception as e:
      syslog.syslog(syslog.LOG_ERR,
                    'error on GET request to %s: %s' % (uri, e))
      return

    return response


class PuavoErsApplet:
  NAKSU_ORIGIN_PATH = '/opt/abitti-naksu/naksu'
  PUAVO_ERS_DIR = os.path.join(os.environ['HOME'], '.puavo', 'puavo-ers')
  CONFIG_PATH = os.path.join(PUAVO_ERS_DIR, 'config.json')
  NAKSU_BIN_PATH = os.path.join(PUAVO_ERS_DIR, 'naksu')
  SERVER_VERSION_PATH  = os.path.join(COMM_DIR, '.server_version')

  def __init__(self):
    self.indicator \
      = AyatanaAppIndicator3.Indicator.new('puavo-ers-applet',
          '/usr/share/icons/Faenza/emblems/64/emblem-default.png',
          AyatanaAppIndicator3.IndicatorCategory.SYSTEM_SERVICES)
    self.indicator.set_status(AyatanaAppIndicator3.IndicatorStatus.ACTIVE)

    self.clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)

    # XXX do we need this?
    Notify.init('puavo-ers-applet')

    os.makedirs(self.PUAVO_ERS_DIR, exist_ok=True)

    self.load_configuration()

    self.menu = Gtk.Menu()
    self.old_exams = None
    self.menuitems = []

    self.indicator.set_menu(self.menu)
    self.latest_chosen_password = None

    self.menu.show_all()

    exam_server = PuavoExamServer()

    self.exam_sync = PuavoErsExamSync(exam_server, self.exam_sync_active)
    self.exam_sync.start()

    self.exam_sorter = PuavoErsExamSorter(self.exam_sync_active)
    self.exam_sorter.start()

    self.exam_control = PuavoErsExamControl(exam_server)
    self.exam_control.start()

    self.exams_server_helper = PuavoErsServerHelper()
    self.exams_server_helper.start()

    self.exams_scheduler = PuavoErsExamScheduler(self.exam_control)
    self.exams_scheduler.start()

    # Copy "naksu" to NAKSU_BIN_PATH only if it does not exist yet.
    # This is because "naksu" is self-updating and self.NAKSU_BIN_PATH
    # likely has an updated version already.
    if not os.path.exists(self.NAKSU_BIN_PATH):
      shutil.copy2(self.NAKSU_ORIGIN_PATH, self.NAKSU_BIN_PATH)


  def load_configuration(self):
    self.automation_active = None
    self.exam_sync_active = None

    error = None
    try:
      with open(self.CONFIG_PATH) as file:
        config = json.load(file)
      if 'automation_active' in config:
        self.automation_active = config['automation_active']
      if 'exam_sync_active' in config:
        self.exam_sync_active = config['exam_sync_active']
    except OSError as e:
      if e.errno != errno.ENOENT:
        error = e
    except Exception as e:
      error = e

    if error:
      syslog.syslog(syslog.LOG_ERR, 'could not read configuration: %s' % error)

    create_defaults = False

    if self.automation_active == None:
      create_defaults = True
      self.automation_active = True
    if self.exam_sync_active == None:
      create_defaults = True
      self.exam_sync_active = True

    if create_defaults:
      self.save_configuration()


  def save_configuration(self):
    try:
      data = {
        'automation_active': self.automation_active,
        'exam_sync_active':  self.exam_sync_active,
      }
      tmpfile = '%s.tmp' % self.CONFIG_PATH
      with open(tmpfile, 'w') as f:
        json.dump(data, f)
      os.rename(tmpfile, self.CONFIG_PATH)
    except Exception as e:
      syslog.syslog(syslog.LOG_ERR, 'could not save configuration: %s' % e)


  def main(self):
    self.run_naksu()
    GLib.timeout_add_seconds(1, self.update_decrypt_codes)

    if self.automation_active and self.exam_sync_active:
      self.enable_exam_scheduler()

    Gtk.main()


  def run_naksu(self):
    syslog.syslog(syslog.LOG_NOTICE, 'starting up naksu')

    cmd = [ '/usr/bin/terminator', '-T', 'naksu terminal',
            '--working-directory=' + self.PUAVO_ERS_DIR,
            '-x', './naksu', '--self-update=enabled' ]
    (pid, stdin, stdout, stderr) = GLib.spawn_async(cmd,
      flags=GLib.SpawnFlags.DO_NOT_REAP_CHILD|GLib.SpawnFlags.STDERR_TO_DEV_NULL,
      standard_input=True, standard_output=True)

    self.naksu_pid = pid

    fl = fcntl.fcntl(stdout, fcntl.F_GETFL)
    fcntl.fcntl(stdout, fcntl.F_SETFL, fl | os.O_NONBLOCK)
    GLib.io_add_watch(stdout, GLib.IO_HUP|GLib.IO_IN,
                      self.handle_naksu, os.fdopen(stdout))


  def handle_naksu(self, fd, condition, channel):
    try:
      if condition & GLib.IO_IN:
        channel.read()

      if condition & GLib.IO_HUP:
        channel.close()
        (pid, status) = os.waitpid(self.naksu_pid, 0)
        if status != 0:
          syslog.syslog(syslog.LOG_ERR,
                        'naksu pid %d returned exit status %s' % (pid, status))
        else:
          syslog.syslog(syslog.LOG_NOTICE, 'naksu exited with success')

        time.sleep(3)
        self.run_naksu()

    except Exception as e:
      syslog.syslog(syslog.LOG_ERR, 'error when handling naksu: %s' % e)
      return False

    return True


  def update_decrypt_codes(self, force_update=False):
    error = None
    try:
      with open(EXAMS_JSON_FILE) as file:
        error_no_exams = False
        try:
          new_exams = json.load(file)
        except Exception as e:
          error_no_exams = True
          new_exams = []
          syslog.syslog(syslog.LOG_ERR,
                        'could not parse exams json: %s' % e)

        if (force_update or self.old_exams != new_exams):
          self.update_decrypt_codes_in_ui(new_exams, error_no_exams)
        self.old_exams = new_exams
    except OSError as e:
      if e.errno != errno.ENOENT:
        error = e
    except Exception as e:
      error = e

    if error:
      # XXX should user be notified?
      syslog.syslog(syslog.LOG_ERR,
                    'error when updating decrypt codes: %s' % error)

    return True


  def update_decrypt_codes_in_ui(self, new_exams, error_no_exams):
    # We can show decrypt codes for future exams as well, in case user
    # wants to try those out manually.  Showing them for old exams is probably
    # just a distraction.

    syslog.syslog(syslog.LOG_INFO, 'updating decrypt codes in UI')

    self.exams_by_widgets = {}
    for menuitem in self.menuitems:
      menuitem.destroy()

    labels_and_exams_list = []
    labels_table = {}

    for exam in new_exams:
      if not re.match('^exam_.*\.me(b|x)$', exam['file_name']):
        syslog.syslog(syslog.LOG_WARNING,
          'not showing password for exam %s' % exam['file_name'])
        continue

      # do not show passwords for old exams
      exam_end_time = datetime.datetime.fromtimestamp(exam['end_time'])
      if exam_end_time < datetime.datetime.now():
        continue

      label = "%s (%s)" % (exam['decrypt_code'], exam['file_name'])
      # Exams may have duplicates, in case there is one exam with multiple
      # start_time/end_times.  Weed out duplicates based on labels_table.
      if label in labels_table:
        continue
      labels_table[label] = 1

      if exam['decrypt_code'] == self.latest_chosen_password:
        label = '***** %s *****' % label

      labels_and_exams_list.append({ 'exam': exam, 'label': label })

    self.make_automation_control_buttons()

    if len(labels_and_exams_list) > 24:
      # we can not fit too many labels on the applet menu,
      # so open a new window in case we have very many exams
      button = Gtk.MenuItem(label=_tr('Open decrypt codes window'))
      decrypt_codes_window = DecryptCodesWindow(self, labels_and_exams_list)
      button.connect('activate', decrypt_codes_window.open)
      button.show()
      self.menu.append(button)
      self.menuitems.append(button)

    elif len(labels_and_exams_list) > 0:
      instructions = Gtk.MenuItem(
        label=_tr('Click passphrase below put it into clipboard'))
      instructions.set_sensitive(False)
      instructions.show()
      self.menuitems.append(instructions)
      self.menu.append(instructions)

      for le in labels_and_exams_list:
        button = Gtk.MenuItem(label=le['label'])
        self.exams_by_widgets[button] = le['exam']
        button.connect('activate', self.password_triggered)
        button.show()
        self.menu.append(button)
        self.menuitems.append(button)

    else:
      no_exams_message = _tr('No current exams')
      if error_no_exams:
        no_exams_message = _tr('No exams due to error')
      instructions = Gtk.MenuItem(label=no_exams_message)
      instructions.set_sensitive(False)
      instructions.show()
      self.menuitems.append(instructions)
      self.menu.append(instructions)


  def make_automation_control_buttons(self):
    if self.exam_sync_active:
      sync_info_button = Gtk.MenuItem(label=_tr('Exam sync is active'))
      sync_info_button.set_sensitive(False)
      sync_control_button = Gtk.MenuItem(label=_tr('Disable exam sync'))
      sync_control_button.connect('activate', self.disable_exam_sync)
    else:
      sync_info_button = Gtk.MenuItem(label=_tr('Exam sync is NOT active'))
      sync_info_button.set_sensitive(False)
      sync_control_button = Gtk.MenuItem(label=_tr('Enable exam sync'))
      sync_control_button.connect('activate', self.enable_exam_sync)

    sync_info_button.show()
    self.menu.append(sync_info_button)
    self.menuitems.append(sync_info_button)

    sync_control_button.show()
    self.menu.append(sync_control_button)
    self.menuitems.append(sync_control_button)

    separator = Gtk.SeparatorMenuItem()
    separator.show()
    self.menuitems.append(separator)
    self.menu.append(separator)

    if self.exams_scheduler.exam_scheduler_enabled:
      auto_info_button = Gtk.MenuItem(
        label=_tr('Exam session automation is active'))
      auto_info_button.set_sensitive(False)
      auto_control_button = Gtk.MenuItem(label=_tr('Disable automation'))
      auto_control_button.connect('activate', self.disable_exam_scheduler)
    else:
      auto_info_button = Gtk.MenuItem(
        label=_tr('Exam session automation is NOT active'))
      auto_info_button.set_sensitive(False)
      auto_control_button = Gtk.MenuItem(label=_tr('Enable automation'))
      auto_control_button.connect('activate', self.enable_exam_scheduler)

    auto_info_button.show()
    self.menu.append(auto_info_button)
    self.menuitems.append(auto_info_button)

    auto_control_button.show()
    auto_control_button.set_sensitive(self.exam_sync_active)
    self.menu.append(auto_control_button)
    self.menuitems.append(auto_control_button)

    separator = Gtk.SeparatorMenuItem()
    separator.show()
    self.menuitems.append(separator)
    self.menu.append(separator)


  def disable_exam_sync(self, widget=None):
    self.exam_sync_active = False
    self.save_configuration()

    self.exam_sorter.exam_sorter_enabled = False
    self.exam_sync.exam_sync_enabled     = False
    self.update_decrypt_codes(True)

    syslog.syslog(syslog.LOG_INFO, 'exam sync is now disabled')
    Notify.Notification.new(_tr('Exam sync is NOT active')).show()

    self.disable_exam_scheduler()


  def enable_exam_sync(self, widget=None):
    self.exam_sync_active = True
    self.save_configuration()

    self.exam_sorter.exam_sorter_enabled = True
    self.exam_sync.exam_sync_enabled     = True
    self.update_decrypt_codes(True)

    syslog.syslog(syslog.LOG_INFO, 'exam sync is now enabled')
    Notify.Notification.new(_tr('Exam sync is active')).show()

    if self.automation_active:
      self.enable_exam_scheduler()


  def disable_exam_scheduler(self, widget=None):
    if widget:
      self.automation_active = False
      self.save_configuration()

    is_enabled = self.exams_scheduler.exam_scheduler_enabled
    self.exams_scheduler.exam_scheduler_enabled = False
    if is_enabled != self.exams_scheduler.exam_scheduler_enabled:
      syslog.syslog(syslog.LOG_INFO, 'exam scheduler is now disabled')
      Notify.Notification.new(_tr('Exam session automation is NOT active')).show()
    self.update_decrypt_codes(True)


  def enable_exam_scheduler(self, widget=None):
    if widget:
      self.automation_active = True
      self.save_configuration()

    current_automation_server_version = None
    current_server_version = None

    try:
      with open(self.SERVER_VERSION_PATH) as f:
        current_automation_server_version = f.read().rstrip()
    except Exception as e:
      pass

    try:
      cmd = [ 'VBoxManage', 'guestproperty', 'get', 'NaksuAbittiKTP',
              'boxVersion' ]
      vbox_output = subprocess.check_output(cmd, stderr=subprocess.DEVNULL) \
                              .rstrip().decode('utf-8')
      match = re.match('^Value: (.*)$', vbox_output)
      if match:
        current_server_version = match.group(1)
    except Exception as e:
      pass

    syslog.syslog(syslog.LOG_NOTICE,
                  'current automation version (for server version): %s' \
                    % current_automation_server_version)
    syslog.syslog(syslog.LOG_NOTICE,
                  'current exam server version: %s' \
                    % current_server_version)

    matching_versions \
      = current_server_version and current_automation_server_version \
          and current_server_version == current_automation_server_version
    if not matching_versions:
      errmsg = 'server automation version does not exist or does not' \
                 + ' match the current server version, will not enable' \
                 + ' the exam scheduler'
      syslog.syslog(syslog.LOG_ERR, errmsg)

      summary = _tr('Install automation helper')
      body = _tr('No trace of exam automation helper could be found,' \
                   + ' please install it into the virtual server' \
                   + ' (execute /media/usb1/ktpapu-asennin in the virtual' \
                   + ' server).')
      Notify.Notification.new(summary, body).show()
      return

    is_enabled = self.exams_scheduler.exam_scheduler_enabled
    self.exams_scheduler.exam_scheduler_enabled = True
    if is_enabled != self.exams_scheduler.exam_scheduler_enabled:
      Notify.Notification.new(_tr('Exam session automation is active')).show()
      syslog.syslog(syslog.LOG_INFO, 'exam scheduler is now enabled')

    self.update_decrypt_codes(True)


  def password_triggered(self, widget):
    password = self.exams_by_widgets[widget]['decrypt_code']
    self.copy_password_to_clipboard(password)


  def copy_password_to_clipboard(self, password):
    syslog.syslog(syslog.LOG_INFO, 'copying password to clipboard')

    self.clipboard.set_text(password, -1)
    self.latest_chosen_password = password
    self.update_decrypt_codes(True)


# This is an alternative window for cases where all the exam decrypt
# codes do not fit into the panel.
class DecryptCodesWindow:
  def __init__(self, applet, labels_and_exams_list):
    self.applet = applet
    self.exams_by_widgets = {}
    self.labels_and_exams_list = labels_and_exams_list
    self.win = None


  def open(self, widget):
    if self.win:
      self.win.present()
      return

    self.win = Gtk.Window(title=_tr('Decrypt codes'))
    self.win.set_default_size(400, 700)
    scrolled_window = Gtk.ScrolledWindow()
    box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
    scrolled_window.add(box)
    self.win.add(scrolled_window)

    instructions = Gtk.Label(
                     _tr('Click passphrase below put it into clipboard'))
    box.pack_start(instructions, True, True, 0)

    for le in self.labels_and_exams_list:
      button = Gtk.Button.new_with_label(le['label'])
      self.exams_by_widgets[button] = le['exam']
      button.connect('clicked', self.password_triggered)
      button.show()
      box.pack_start(button, True, True, 0)

    self.win.connect('destroy', self.window_closed)
    self.win.show_all()


  def password_triggered(self, widget):
    password = self.exams_by_widgets[widget]['decrypt_code']
    self.applet.copy_password_to_clipboard(password)


  def window_closed(self, widget):
    self.win = None


class PuavoErsExamSync (threading.Thread):
  def __init__(self, exam_server, is_active):
    threading.Thread.__init__(self)

    self.exam_server = exam_server
    self.exam_sync_enabled = is_active


  def run(self):
     is_enabled = None

     while True:
       try:
         if self.exam_sync_enabled:
           self.sync_exams()
         elif is_enabled != self.exam_sync_enabled:
           syslog.syslog(syslog.LOG_INFO, 'exam sync has been disabled')
           is_enabled = self.exam_sync_enabled

       except Exception as e:
         syslog.syslog(syslog.LOG_ERR, 'error when syncing exams: %s' % e)

       time.sleep(60)


  def sync_exams(self):
    syslog.syslog(syslog.LOG_INFO, 'requesting for new exams')

    response = self.exam_server.get('/v1/schedules/query_exam_server_schedule')
    if not response or response.status_code != requests.codes.ok:
      return

    exams_json = response.content.decode('utf-8')
    self.update_exams_json_on_disk(exams_json)

    exam_name_list = []
    for exam in json.loads(exams_json):
      try:
        exam_file_name = exam['file_name']
        if not isinstance(exam_file_name, str):
          raise Exception('could not determine exam filename')
        if exam_file_name == '':
          raise Exception('could not determine exam filename')
        if not re.match('^exam_.*\.me(b|x)$', exam_file_name):
          raise Exception('not syncing exam with a filename %s' \
                            % exam_file_name)

        self.sync_one_exam(exam_file_name, exam)
        exam_name_list.append(exam_file_name)
      except Exception as e:
        syslog.syslog(syslog.LOG_ERR, 'error in syncing one exam: %s' % e)

    # clean up old exams that no longer belong to exams subdirectories
    for exam_path in glob.glob( os.path.join(EXAMS_DIR, 'exam_*.me[bx]') ):
      if not os.path.basename(exam_path) in exam_name_list:
        # We check that file hard link count must be over 1, in which case
        # it has already been archived and we can delete it here.
        if os.stat(exam_path).st_nlink > 1:
          rm_f(exam_path)


  def update_exams_json_on_disk(self, exams_json):
    try:
      tmpfile = '%s.tmp' % EXAMS_JSON_FILE
      with open(tmpfile, 'w') as f:
        f.write(exams_json)
      os.rename(tmpfile, EXAMS_JSON_FILE)
    except Exception as e:
      # XXX should user be notified?
      syslog.syslog(syslog.LOG_CRIT,
        'error in writing exams (json) to %s: %s' % (EXAMS_JSON_FILE, e))


  def sync_one_exam(self, exam_file_name, exam):
    exam_file_path = os.path.join(EXAMS_DIR, exam_file_name)
    if os.path.isfile(exam_file_path):
      return

    syslog.syslog(syslog.LOG_NOTICE, 'syncing exam %s' % exam_file_name)

    exam_hash = exam['file_sha256']
    if not isinstance(exam_hash, str):
      raise Exception('could not determine exam hash for %s' % exam_file_name)

    exam_params = { 'hash': exam_hash }
    response = self.exam_server.get('/v1/exams/raw_file', exam_params)
    if not response or response.status_code != requests.codes.ok:
      raise Exception('error when getting an exam %s' % exam_file_name)

    exam_contents = response.content
    if exam_hash != hashlib.sha256(exam_contents).hexdigest():
      raise Exception('exam checksum did not match for %s' % exam_file_name)

    tmpfile = '%s.tmp' % exam_file_path
    with open(tmpfile, 'wb') as f:
      f.write(exam_contents)
    os.rename(tmpfile, exam_file_path)

    syslog.syslog(syslog.LOG_INFO, 'exam %s synced okay' % exam_file_name)


class PuavoErsExamControl (threading.Thread):
  STATUS_PATH = os.path.join(COMM_DIR, '.status.json')

  def __init__(self, exam_server):
    threading.Thread.__init__(self)

    self.exam_server = exam_server

    self.send_status_update = threading.Condition()
    self.status = None
    self.status_updated = False


  def run(self):
    while True:
      try:
        self.send_status_update.acquire()

        while not self.status_updated:
          self.send_status_update.wait()

        status_copy = copy.deepcopy(self.status)
        self.status_updated = False
        self.send_status_update.release()

        self.send_status(status_copy)
      except Exception as e:
        syslog.syslog(syslog.LOG_ERR,
                      'error when sending status update: %s' % e)


  def send_status(self, status):
    syslog.syslog(syslog.LOG_INFO, 'sending status update to server')

    status_path = '/v1/exam_session_status'

#     response = requests.get(index_uri,
#                             auth=HTTPBasicAuth(self.ldap_dn,
#                                                self.ldap_password),
#                             params={
#                               'domain':   self.domain,
#                               'hostname': self.hostname,
#                               'id':       self.id,
#                             },
#                             timeout=20)


  def update_status(self, new_status):
    self.send_status_update.acquire()

    if self.status != new_status:
      self.status = new_status
      syslog.syslog(syslog.LOG_INFO,
                    'received status update from exam scheduler')
      self.status_updated = True
      self.send_status_update.notify()

    self.send_status_update.release()


  def save_status_to_disk(self):
    # This method has no other purpose except to help with
    # monitoring/debugging.  Perhaps this should be removed?
    try:
      tmpfile = '%s.tmp' % self.STATUS_PATH
      with open(tmpfile, 'w') as f:
        json.dump(self.status, f)
      os.rename(tmpfile, self.STATUS_PATH)
    except Exception as e:
      syslog.syslog(syslog.LOG_ERR,
                    'error when saving status to disk: %s' % e)


class ExamSet:
  def __init__(self, exams):
    self.exams = exams

    self.earliest_start_time = None
    self.latest_end_time     = None

    self.update_earliest_and_latest()


  def update_earliest_and_latest(self):
    for exam in self.exams:
      exam_start_time = datetime.datetime.fromtimestamp(exam['start_time'])
      exam_end_time   = datetime.datetime.fromtimestamp(exam['end_time'])

      if not self.earliest_start_time \
        or exam_start_time < self.earliest_start_time:
          self.earliest_start_time = exam_start_time
      if not self.latest_end_time or (exam_end_time < self.latest_end_time):
        self.latest_end_time = exam_end_time


  def add_overlapping_exams(self, candidate_exams_to_be_added, now):
    candidate_exams = candidate_exams_to_be_added.copy()

    if len(self.exams) == 0:
      return

    while len(candidate_exams) > 0:
      candidate_accepted = False
      for exam in candidate_exams:
        exam_start_time = datetime.datetime.fromtimestamp(exam['start_time'])
        exam_end_time   = datetime.datetime.fromtimestamp(exam['end_time'])

        if exam_start_time < self.latest_end_time \
          and self.earliest_start_time < exam_end_time:
            candidate_accepted = True

        if candidate_accepted:
          candidate_exams.remove(exam)
          if not exam in self.exams:
            self.exams.append(exam)
          if exam_start_time < self.earliest_start_time:
            self.earliest_start_time = exam_start_time
          if self.latest_end_time < exam_end_time:
            self.latest_end_time = exam_end_time
          break

      # If we have not managed to remove any exam from the candidate list,
      # there can no more exams to check.
      if not candidate_accepted:
        break


class PuavoErsExamSorter (threading.Thread):
  def __init__(self, is_active):
    threading.Thread.__init__(self)

    self.exam_sorter_enabled    = is_active
    self.previous_current_exams = None
    self.previous_todays_exams  = None


  def run(self):
    is_enabled = None

    while True:
      try:
        if self.exam_sorter_enabled:
          with exam_scheduler_lock:
            self.sort_exams_to_dirs()
        elif is_enabled != self.exam_sorter_enabled:
          syslog.syslog(syslog.LOG_INFO, 'exam sorter has been disabled')
          is_enabled = self.exam_sorter_enabled

      except Exception as e:
        syslog.syslog(syslog.LOG_ERR, 'error when sorting exams: %s' % e)

      time.sleep(10)


  def sort_exams_to_dirs(self):
    global current_exams_set

    self.current_day  = datetime.date.today()
    self.current_time = datetime.datetime.now()

    try:
      with open(EXAMS_JSON_FILE) as file:
        all_exams = json.load(file)
    except OSError as e:
      if e.errno != errno.ENOENT:
        raise e
      return

    archived_exams_filenames = []
    current_exams            = []
    current_exams_filenames  = []
    todays_exams             = []
    todays_exams_filenames   = []
    upcoming_exams_filenames = []

    decrypt_codes_list = []

    for exam in all_exams:
      try:
        if not re.match('^exam_.*\.me(b|x)$', exam['file_name']):
          raise Exception('ignoring exam with a file name %s' \
                            % exam['file_name'])

        exam_start_day  = datetime.date.fromtimestamp(exam['start_time'])
        exam_start_time = datetime.datetime.fromtimestamp(exam['start_time'])

        exam_end_day    = datetime.date.fromtimestamp(exam['end_time'])
        exam_end_time   = datetime.datetime.fromtimestamp(exam['end_time'])

        if exam_end_day < self.current_day:
          archived_exams_filenames.append(exam['file_name'])
        elif self.current_day < exam_start_day:
          upcoming_exams_filenames.append(exam['file_name'])
        else:
          todays_exams.append(exam)
          todays_exams_filenames.append(exam['file_name'])

        # Load new exams to server 10 minutes before they are scheduled
        # to start.  Note that if exams are scheduled to have less than
        # 10 minutes between them, add_overlapping_exams() below will consider
        # them to be part of the same exam set (session).
        preload_timedelta = datetime.timedelta(minutes=10)
        if (exam_start_time - preload_timedelta) <= self.current_time \
          and self.current_time < exam_end_time:
            current_exams.append(exam)

      except Exception as e:
        syslog.syslog(syslog.LOG_ERR, 'could not handle an exam: %s' % e)

    current_exams_set = ExamSet(current_exams)
    current_exams_set.add_overlapping_exams(todays_exams, self.current_time)

    for exam in current_exams_set.exams:
      current_exams_filenames.append(exam['file_name'])
      decrypt_codes_list.append(exam['decrypt_code'])

    self.handle_archive(archived_exams_filenames)

    self.cleanup_exams(KTP_JAKO_DIR, todays_exams_filenames)
    self.link_exams_to_dir(KTP_JAKO_DIR, todays_exams_filenames)

    self.cleanup_exams(EXAMS_UPCOMING_DIR, upcoming_exams_filenames)
    self.link_exams_to_dir(EXAMS_UPCOMING_DIR, upcoming_exams_filenames)

    self.zip_exams(current_exams_filenames, todays_exams_filenames,
        decrypt_codes_list)


  def cleanup_exams(self, linkdir, exam_filenames):
    for path in glob.glob( os.path.join(linkdir, 'exam_*.me[bx]') ):
      if not os.path.basename(path) in exam_filenames:
        rm_f(path)


  def handle_archive(self, exam_filenames):
    self.link_exams_to_dir(EXAMS_ARCHIVE_DIR, exam_filenames)

    for path in glob.glob( os.path.join(EXAMS_ARCHIVE_DIR, 'exam_*.me[bx]') ):
      try:
        file_atime = os.stat(path).st_atime
        # keep archived files for two weeks
        if (file_atime + 60 * 60 * 24 * 14) < self.current_time.timestamp():
          syslog.syslog(syslog.LOG_NOTICE,
                        'removing from archive: %s' % path)
          rm_f(path)
      except Exception as e:
        syslog.syslog(syslog.LOG_ERR,
                      'error in checking old archive file %s: %s' \
                        % (path, e))


  def link_exams_to_dir(self, linkdir, exam_filenames):
    for exam_name in exam_filenames:
      exam_path = os.path.join(EXAMS_DIR, exam_name)
      try:
        target_path = os.path.join(linkdir, exam_name)
        os.link(exam_path, target_path)
        syslog.syslog(syslog.LOG_INFO,
                      'exam %s linked to %s' % (exam_path, linkdir))

        # updates access time only when link has been made
        st = os.stat(target_path)
        os.utime(target_path,
                 (datetime.datetime.now().timestamp(), st.st_mtime))
      except OSError as e:
        if e.errno == errno.EEXIST:
          pass
        elif e.errno == errno.ENOENT:
          syslog.syslog(syslog.LOG_ERR, 'could not find exam %s' % exam_path)
        else:
          raise e


  def zip_exams(self, current_exams_filenames, todays_exams_filenames,
                decrypt_codes_list):
    global current_zip_name

    current_zip_name = 'Menossa-%s.zip' % self.current_day
    todays_zip_name  = 'Kaikki-%s.zip'  % self.current_day

    current_exams_filenames.sort()
    todays_exams_filenames.sort()

    current_zip_path = os.path.join(KTP_JAKO_DIR, current_zip_name)
    todays_zip_path  = os.path.join(KTP_JAKO_DIR, todays_zip_name)

    try:
      if not os.path.exists(current_zip_path) \
        or current_exams_filenames != self.previous_current_exams:
          self.zip_an_exam_set(current_exams_filenames, current_zip_path,
                               decrypt_codes_list)
          self.previous_current_exams = current_exams_filenames
    except Exception as e:
      syslog.syslog(syslog.LOG_ERR,
        'error when zipping current exams (or updating decrypt codes): %s' % e)

    try:
      if not os.path.exists(todays_zip_path) \
        or todays_exams_filenames != self.previous_todays_exams:
          self.zip_an_exam_set(todays_exams_filenames, todays_zip_path)
          self.previous_todays_exams = todays_exams_filenames
    except Exception as e:
      syslog.syslog(syslog.LOG_ERR, 'error when zipping todays exams: %s' % e)

    current_zip_files = glob.glob( os.path.join(KTP_JAKO_DIR, 'Menossa-*.zip') )
    todays_zip_files  = glob.glob( os.path.join(KTP_JAKO_DIR, 'Kaikki-*.zip') )
    for zipfile in (current_zip_files + todays_zip_files):
      if not zipfile in [ current_zip_path, todays_zip_path ]:
        rm_f(zipfile)


  def zip_an_exam_set(self, exams, zip_path, decrypt_codes_list=None):
    if len(exams) == 0:
      if os.path.exists(zip_path):
        rm_f(zip_path)
        if decrypt_codes_list != None:
          self.update_decrypt_codes_in_file(decrypt_codes_list)
      return

    exam_paths = [ os.path.join(KTP_JAKO_DIR, p) for p in exams ]
    unique_exam_paths = list( dict.fromkeys(exam_paths) )
    syslog.syslog(syslog.LOG_INFO,
                  'zipping exams %s into %s' % (exams, zip_path))
    tmpfile = "%s.tmp" % zip_path
    rm_f(tmpfile, False)
    with zipfile.ZipFile(tmpfile, 'w') as zipObj:
      for filename in unique_exam_paths:
        zipObj.write(filename, os.path.basename(filename))
    os.rename(tmpfile, zip_path)

    if decrypt_codes_list != None:
     self.update_decrypt_codes_in_file(decrypt_codes_list)


  def update_decrypt_codes_in_file(self, decrypt_codes_list):
    DECRYPT_CODES_PATH = os.path.join(KTP_JAKO_DIR, 'PURKUKOODIT.TXT')

    syslog.syslog(syslog.LOG_INFO,
                  'updating decrypt codes in %s' % DECRYPT_CODES_PATH)

    tmpfile = '%s.tmp' % DECRYPT_CODES_PATH
    with open(tmpfile, 'w') as f:
      decrypt_codes_list.sort()
      for decrypt_code in decrypt_codes_list:
        f.write("%s\n" % decrypt_code)
    os.rename(tmpfile, DECRYPT_CODES_PATH)


class PuavoErsServerHelper (threading.Thread):
  MGMT_INSTALL_SOURCE_PATH = '/opt/abitti-ktpapi/ktpapu-asennin'
  MGMT_INSTALL_TARGET_PATH = os.path.join(KTP_JAKO_DIR, 'ktpapu-asennin')

  def run(self):
    while True:
      try:
        update = False
        try:
          if os.path.exists(self.MGMT_INSTALL_SOURCE_PATH):
            if not filecmp.cmp(self.MGMT_INSTALL_SOURCE_PATH,
                               self.MGMT_INSTALL_TARGET_PATH):
              update = True
        except OSError as e:
          if e.errno != errno.ENOENT:
            raise e
          update = True

        if update:
          syslog.syslog(syslog.LOG_NOTICE,
                        'copying/updating %s to %s' \
                          % (self.MGMT_INSTALL_SOURCE_PATH,
                             self.MGMT_INSTALL_TARGET_PATH))
          shutil.copy2(self.MGMT_INSTALL_SOURCE_PATH,
                       self.MGMT_INSTALL_TARGET_PATH)

      except Exception as e:
        syslog.syslog(syslog.LOG_ERR,
                      'error when managing exams dir: %s' % e)

      time.sleep(60)


class PuavoErsExamScheduler (threading.Thread):
  CMD_IN_PROGRESS_PATH = os.path.join(COMM_DIR, '.cmd-in-progress')
  CMD_PATH             = os.path.join(COMM_DIR, 'cmd')
  CMD_RESULT_PATH      = os.path.join(COMM_DIR, 'cmd-result')
  CMD_STAMP_PATH       = os.path.join(COMM_DIR, 'cmd-stamp')
  DEBUG_OUTPUT_PATH    = os.path.join(COMM_DIR, 'debug-output')
  EXAM_ANSWERS_PATH    = os.path.join(COMM_DIR, 'answers.zip')
  EXAMS_PATH           = os.path.join(COMM_DIR, 'exams')
  OUTPUT_PATH          = os.path.join(COMM_DIR, 'output')
  STATS_PATH           = os.path.join(COMM_DIR, 'stats')


  def __init__(self, exam_control):
    threading.Thread.__init__(self)

    self.answers_stored_time    = None
    self.exam_control           = exam_control
    self.exam_scheduler_enabled = False
    self.finished_and_students  = None
    self.finish_time            = self.end_of_today()


  def get_exams(self):
    return self.server_cmd('get-exam')


  def get_status(self):
    return self.server_cmd('get-status')


  def load_empty_examset(self):
    empty_zip_file_name = 'empty_exams_set.zip'
    empty_zip_file      = os.path.join(KTP_JAKO_DIR, empty_zip_file_name)

    tmpfile = '%s.tmp' % empty_zip_file
    rm_f(tmpfile, False)
    with zipfile.ZipFile(tmpfile, 'w') as zipObj:
      zipObj.writestr('EMPTY', '')
    os.rename(tmpfile, empty_zip_file)

    codes_file_name = 'empty_decrypt_codes.txt'
    codes_file      = os.path.join(KTP_JAKO_DIR, codes_file_name)
    rm_f(codes_file, False)
    with open(codes_file, 'w') as f:
      pass

    cmd = 'load-exam %s %s' % (empty_zip_file_name, codes_file_name)
    status = self.server_cmd(cmd)

    rm_f(empty_zip_file, False)
    rm_f(codes_file, False)

    return status



  def load_exams(self):
    global current_zip_name

    if current_zip_name == None:
      raise CurrentZipNotReady

    cmd = 'load-exam %s %s' % (current_zip_name, 'PURKUKOODIT.TXT')
    return self.server_cmd(cmd)


  def start_loaded_exams(self):
    return self.server_cmd('start-loaded-exam')


  def store_exam_results(self, results_filepath):
    self.server_cmd('store-exam-results')
    syslog.syslog(syslog.LOG_INFO,
                  'storing exam answers to %s' % results_filepath)
    shutil.copy2(self.EXAM_ANSWERS_PATH, results_filepath)


  def ping(self):
    return self.server_cmd('ping')


  def run(self):
    global current_exams_set

    comm_ok = False
    is_enabled = None
    old_comm_state = None

    while True:
      try:
        if not comm_ok:
          output = self.ping()
          if output['error'] == False:
            comm_ok = True
            if old_comm_state != comm_ok:
              syslog.syslog(syslog.LOG_NOTICE,
                            'communication link to exam server is ok')
          else:
            comm_ok = False
            if old_comm_state != comm_ok:
              syslog.syslog(syslog.LOG_INFO,
                            'no communication link to exam server')

        old_comm_state = comm_ok

        if comm_ok:
          with exam_scheduler_lock:
            self.schedule_exams(current_exams_set)

      except ExamSchedulerNotActive as e:
        if is_enabled != self.exam_scheduler_enabled:
          syslog.syslog(syslog.LOG_INFO, 'exam scheduler has been disabled')
          is_enabled = self.exam_scheduler_enabled

      except Exception as e:
        comm_ok = False
        syslog.syslog(syslog.LOG_ERR,
                      'error when scheduling exams: %s' % e)

      time.sleep(3)


  def maybe_store_answers(self, currently_loaded_exams, status):
    if len(currently_loaded_exams) == 0:
      return

    now = datetime.datetime.now()
    if now < self.finish_time:
      return

    there_should_be_answers = False
    for student in status['students']:
      if ('updateTime' in student) and (student['updateTime'] != None):
        there_should_be_answers = True

    if self.answers_stored_time \
      and self.answers_stored_time >= self.finish_time:
        return

    if there_should_be_answers:
      self.store_answers(currently_loaded_exams)
    else:
      # Trying to store answers when there are none returns an error.
      # Perhaps this logic could be such that it is left for abitti-ktpapi
      # to check if there are answers? (that might be less error-prone)
      syslog.syslog(syslog.LOG_INFO, 'there are no answers, not storing them')

    self.answers_stored_time = now


  def store_answers(self, currently_loaded_exams):
    now_as_string = datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')

    if len(currently_loaded_exams) == 1:
      title = currently_loaded_exams[0]['examTitle']
      title_no_whitespace = title.replace(' ', '_')
      title_detox = re.sub(r'[^A-Za-z0-9_]+', '', title_no_whitespace)
      answers_filename = 'answers_%s_%s.meb' % (title_detox, now_as_string)
    else:
      answers_filename = 'multianswers_%s.meb' % now_as_string

    answers_filename_fp = os.path.join(ANSWERS_DIR, answers_filename)
    self.store_exam_results(answers_filename_fp)


  def exams_are_finished(self):
    if datetime.datetime.now() > self.finish_time:
      syslog.syslog(syslog.LOG_INFO, 'exams finish time is past: %s' \
                                       % self.finish_time)
      return True

    syslog.syslog(syslog.LOG_INFO,
                  'we are waiting for exams to finish at: %s' \
                    % self.finish_time)
    return False


  def there_are_still_active_students(self, status):
    now = datetime.datetime.now()

    for student in status['students']:
      if ('examFinished' in student) and (student['examFinished'] != None):
        # this student has finished the exam, does not count
        continue

      if ('pingError' in student) and (student['pingError'] == False):
        # someone still has a connection, we have at least one active student
        return True

      # this student has npt finished, yet has no active connection
      if ('updateTime' in student) and (student['updateTime'] != None):
        update_time = datetime.datetime.strptime(
                        student['updateTime'], '%Y-%m-%dT%H:%M:%S.%f%z')\
                          .astimezone()
        five_minutes_before_now = now - datetime.timedelta(minutes=5)
        if update_time >= five_minutes_before_now.astimezone():
          # but he/she has updated in the last five minutes, so still counts
          # as active
          return True

    # no student is active
    return False


  def get_last_finished_time(self, status):
    last_finished_time = None
    for student in status['students']:
      if ('examFinished' in student) and (student['examFinished'] != None):
        finish_time = datetime.datetime.strptime(
                        student['examFinished'], '%Y-%m-%dT%H:%M:%S.%f%z')\
                          .astimezone()
        if not last_finished_time or last_finished_time < finish_time:
          last_finished_time = finish_time

    return last_finished_time


  def update_exams_finished_time(self, status):
    if self.there_are_still_active_students(status):
      syslog.syslog(syslog.LOG_INFO, 'there are still active students')
      self.finish_time = self.end_of_today()
    else:
      now = datetime.datetime.now()

      last_finished_time = self.get_last_finished_time(status)
      if last_finished_time:
        if self.finish_time.astimezone() < last_finished_time:
          syslog.syslog(syslog.LOG_INFO, 'no active students, exams finished')
          self.finish_time = now

      if self.finish_time > now:
        self.finish_time = now


  def schedule_exams(self, current_exams_set):
    status_response = self.get_status()
    status = status_response['status']
    has_started = (status['hasStarted'] == True)

    self.exam_control.update_status(status)

    if not self.exam_scheduler_enabled:
      raise ExamSchedulerNotActive

    exams_response = self.get_exams()
    currently_loaded_exams = exams_response['exams']
    currently_loaded_exam_uuids \
      = [ exam['examUuid'] for exam in currently_loaded_exams ]

    self.update_exams_finished_time(status)

    exams_finished = self.exams_are_finished()
    if exams_finished:
      self.maybe_store_answers(currently_loaded_exams, status)

    if has_started and not exams_finished:
      syslog.syslog(syslog.LOG_INFO,
                    'examinations are in progress, not loading any exams')
      return

    if len(current_exams_set.exams) == 0:
      if has_started:
        msg = 'exams ongoing but should not be according to schedule,' \
                 + ' resetting server state'
        syslog.syslog(syslog.LOG_INFO, msg)
        self.load_empty_examset()
      else:
        syslog.syslog(syslog.LOG_INFO, 'no exams to schedule')
      return

    current_exam_uuids = []
    for exam in current_exams_set.exams:
      if not 'uuid' in exam:
        errmsg = 'no uuid set for exam "%s", can not check it is on server' \
                   % exam['file_name']
        raise Exception(errmsg)
      current_exam_uuids.append(exam['uuid'])

    try:
      if set(currently_loaded_exam_uuids) != set(current_exam_uuids):
        syslog.syslog(syslog.LOG_INFO, 'loading exams')
        self.load_exams()
        self.finish_time = current_exams_set.latest_end_time
        has_started = False
    except CurrentZipNotReady as e:
      syslog.syslog(syslog.LOG_INFO,
                    'exam scheduler is waiting for zip file to be ready')
      return

    if not has_started \
      and current_exams_set.earliest_start_time <= datetime.datetime.now():
        syslog.syslog(syslog.LOG_NOTICE, 'starting up exams')
        self.start_loaded_exams()


  def end_of_today(self):
    now = datetime.datetime.now()
    start_of_today = datetime.datetime(now.year, now.month, now.day)
    return start_of_today + datetime.timedelta(days=1)


  def server_cmd(self, cmd):
    try:
      return self.try_server_cmd(cmd)
    except Exception as e:
      raise Exception('error with "%s": %s' % (cmd, e))


  def try_server_cmd(self, cmd):
    syslog.syslog(syslog.LOG_INFO, 'sending command to exam server: "%s"' % cmd)
    output_paths = [ self.CMD_IN_PROGRESS_PATH, self.CMD_RESULT_PATH,
                     self.DEBUG_OUTPUT_PATH, self.EXAMS_PATH, self.OUTPUT_PATH,
                     self.STATS_PATH ]
    for path in output_paths:
      rm_f(path, False)

    try:
      if not os.path.isdir(COMM_DIR):
        errmsg = 'communication directory does not exist,' \
                   + ' ktpapi is not installed in virtual server'
        raise Exception(errmsg)

      with open(self.CMD_IN_PROGRESS_PATH, 'w') as f:
        pass

      with open(self.CMD_PATH, 'w') as f:
        f.write("%s\n" % cmd)

      for i in range(30):
        try:
          if not os.path.exists(self.CMD_IN_PROGRESS_PATH):
            with open(self.OUTPUT_PATH) as f:
              output = f.read()
              parsed_output = json.loads(output)
              if not 'error' in parsed_output:
                raise Exception('server response did not contain an error key')
              if parsed_output['error'] != False:
                raise Exception('server returned error: %s' \
                                  % parsed_output['error'])
              return parsed_output
        except OSError as e:
          if e.errno != errno.ENOENT:
            raise e

        time.sleep(1)
    finally:
      rm_f(self.CMD_IN_PROGRESS_PATH, False)

    raise Exception('timeout when reading server response')


syslog.openlog('puavo-ers-applet')

syslog.syslog(syslog.LOG_NOTICE, 'puavo-ers-applet starting up')

applet = PuavoErsApplet()

dirs_to_create = [ KTP_JAKO_DIR, ANSWERS_DIR, EXAMS_DIR, EXAMS_ARCHIVE_DIR,
                   EXAMS_UPCOMING_DIR ]
for dir in dirs_to_create:
  try:
    os.mkdir(dir)
  except OSError as e:
    if e.errno != errno.EEXIST:
      raise e

if __name__ == '__main__':
  signal.signal(signal.SIGINT, signal.SIG_DFL)
  applet.main()

syslog.closelog()
