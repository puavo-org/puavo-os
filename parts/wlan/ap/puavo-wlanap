#!/bin/bash

set -eubm

on_sigchld()
{
    if [ ! -f "${PWAP_RUNDIR}/critical_service.pids" ]; then
        return
    fi

    # We track our "critical child services" by appending their PIDs to
    # a list after a successful spawn (see start_services()) and then
    # whenever any of our child processes dies, check if any of the
    # critical child services is dead, make a suicide.
    while read critical_service_pid; do
        kill -0 "${critical_service_pid}" || {
            echo "fatal: a critical child service has died, exiting" >&2
            on_exit
        }
    done <"${PWAP_RUNDIR}/critical_service.pids"
}

on_exit()
{
    local -r exitval=$?
    local net ssid bridge

    ## Do not exit or terminate on error or signal anymore. We are
    ## already exiting and it would be shame to exit while exiting, yo
    ## dawg.
    set +eu
    trap '' EXIT HUP INT QUIT ABRT ALRM TERM USR1 USR2 CHLD

    ## Kill our child processes. There is no reason to let Init adopt
    ## them when puavo-wlanap dies.
    pkill -TERM -P $$

    ## Burn the bridges.
    for net in "${PWAP_NETS[@]}"; do
        IFS=':' read _ ssid _ <<<"${net}"
        bridge=$("${PWAP_LIBDIR}/get-bridge" "${ssid}")
        ifconfig "${bridge}" down
        brctl delbr "${bridge}"
    done

    rm -rf "${PWAP_RUNDIR}"

    echo "exit $exitval" >&2
    exit $exitval
}

write_hostapd_conf()
{
    local radio channel iface ssid_count bssid net auth ssid psk bridge hw_mode

    ## Configure one hostapd per radio.
    for radio in "${PWAP_RADIOS[@]}"; do
        IFS=':' read channel iface <<<"${radio}"
        ssid_count=0
        bssid=$("${PWAP_LIBDIR}/get-bssid" "${iface}")

        [ -n "${bssid}" ] || {
            pwap_log "failed to find the first address in the block"
            return 1
        }

        ht_capab=$("${PWAP_LIBDIR}/get-ht-capab" "${iface}" "${channel}")

        case "${channel}" in
            36|40|44|48)
                hw_mode=a
                ;;
            *)
                hw_mode=g
                ;;
        esac

        echo "### PHY-specific options ###" \
            >"${PWAP_RUNDIR}/${iface}_hostapd.conf"
        sed -e "s|#{PWAP_IFACE}|${iface}|g" \
            -e "s|#{PWAP_BSSID}|${bssid}|g" \
            -e "s|#{PWAP_CHANNEL}|${channel}|g" \
            -e "s|#{PWAP_HW_MODE}|${hw_mode}|g" \
            -e "s|#{PWAP_RUNDIR}|${PWAP_RUNDIR}|g" \
            -e "s|#{PWAP_HT_CAPAB}|${ht_capab}|g" \
            "${PWAP_DATADIR}/common.conf" \
            >>"${PWAP_RUNDIR}/${iface}_hostapd.conf"

        for net in "${PWAP_NETS[@]}"; do
            IFS=':' read auth ssid psk <<<"${net}"

            bridge=$("${PWAP_LIBDIR}/get-bridge" "${ssid}")

            cat <<EOF >>"${PWAP_RUNDIR}/${iface}_hostapd.conf"

### BSS-specific options ###
EOF

            if [ "${ssid_count}" -gt 0 ]; then
                echo "bss=${iface}_${ssid_count}" \
                    >>"${PWAP_RUNDIR}/${iface}_hostapd.conf"
            fi

            cat "${PWAP_DATADIR}/${auth}_hostapd.conf" \
                >>"${PWAP_RUNDIR}/${iface}_hostapd.conf"
            sed -i \
                -e "s|#{PWAP_SSID}|${ssid}|g" \
                -e "s|#{PWAP_BRIDGE}|${bridge}|g" \
                -e "s|#{PWAP_PSK}|${psk}|g" \
                "${PWAP_RUNDIR}/${iface}_hostapd.conf"
            ssid_count=$((ssid_count + 1))
        done
    done
}

write_vtund_conf()
{
    local net ssid session bridge

    ## Configure one vtund client per network.
    for net in "${PWAP_NETS[@]}"; do
        IFS=':' read _ ssid _ <<<"${net}"

        bridge=$("${PWAP_LIBDIR}/get-bridge" "${ssid}")

        if [ ${PWAP_LEGACY_MODE} -eq 0 ]; then
            session="${ssid}"
        else
            session="puavo-wlanap"
        fi

        sed -e "s|#{PWAP_LIBDIR}|${PWAP_LIBDIR}|g" \
            -e "s|#{PWAP_BRIDGE}|${bridge}|g" \
            -e "s|#{PWAP_RUNDIR}|${PWAP_RUNDIR}|g" \
            -e "s|#{PWAP_SESSION}|${session}|g" \
            "${PWAP_DATADIR}/vtund.conf" \
            >"${PWAP_RUNDIR}/${ssid}_vtund.conf"
    done
}

setup_nets()
{
    local net auth ssid psk ap_ssid fetch_wait

    # if we do not have a list of networks to setup, try again later
    fetch_wait=1
    while true; do
      "${PWAP_LIBDIR}/fetch-nets" > "${PWAP_RUNDIR}/nets"
      test -s "${PWAP_RUNDIR}/nets" && break
      fetch_wait=$((2 * $fetch_wait))
      if [ "$fetch_wait" -gt 3600 ]; then
        fetch_wait=3600
      fi
      pwap_log "no networks to setup yet, refetching after $fetch_wait seconds"
      sleep $fetch_wait
    done

    pwap_log "fetched networks successfully"

    # Magic SSID Mangling! The following Magic SSID is substituted with
    # a SSID derived from the hostname. This lets us configure
    # AP-specific networks easily via Puavo.
    ap_ssid=$(hostname | tr -d [:space:] | tail -c15)
    sed -i -r "s/:le8Yuek9Some5ee:/:${ap_ssid}:/" "${PWAP_RUNDIR}/nets"

    readarray -n4 -t PWAP_NETS <"${PWAP_RUNDIR}/nets"

    if [ ${#PWAP_NETS[@]} -eq 0 ]; then
        pwap_log "no networks defined"
        return 1
    fi

    for net in "${PWAP_NETS[@]}"; do
        IFS=':' read auth ssid psk <<<"${net}"
        case "${auth}" in
            open)
                if [ -n "${psk}" ]; then
                    pwap_log "auth type is 'open', but psk was defined"
                fi
                ;;
            psk)
                if [ "${#psk}" -lt 8 -o "${#psk}" -gt 63 ]; then
                    pwap_log "psk must be 8-63 characters long"
                    return 1
                fi
                ;;
            *)
                pwap_log "unknown auth type '${auth}'"
                return 1
                ;;
        esac
    done

    if [ ${PWAP_LEGACY_MODE} -eq 0 ]; then
        ## Tell gateway which networks we are going to provide.
        for net in "${PWAP_NETS[@]}"; do
            IFS=':' read _ ssid _ <<<"${net}"
            echo "${ssid}" | nc "${PWAP_GWADDR}" "${PWAP_GWPORT_CTRL}"
        done
    fi
}

setup_radios()
{
    local i

    local channel
    local channels_ag
    local channels_a
    local channels_g

    local iface
    local ifaces_ag
    local ifaces_a
    local ifaces_g

    local used_channels=()
    used_channels[1]=0
    used_channels[6]=0
    used_channels[11]=0
    used_channels[36]=0
    used_channels[40]=0
    used_channels[44]=0
    used_channels[48]=0

    PWAP_RADIOS=()

    "${PWAP_LIBDIR}/find-ifaces" | while read iface; do
        ifconfig "${iface}" up
    done

    channels=($("${PWAP_LIBDIR}/scan-channels" 1 6 11 36 40 44 48))
    if [ ${#channels[@]} -ne 7 ]; then
        echo "Failed to scan channels, falling back to random channel selection" >&2
        channels=($(printf '%d\n' 1 6 11 36 40 44 48 | sort -R))
    fi

    echo ${channels[@]} >"${PWAP_RUNDIR}/channels"

    channels_a=($(printf '%s\n' ${channels[@]} | sed -r -n 's/^(36|40|44|48)$/\1/p'))
    channels_g=($(printf '%s\n' ${channels[@]} | sed -r -n 's/^(1|6|11)$/\1/p'))

    ifaces_a=$({ "${PWAP_LIBDIR}/find-ifaces" a; "${PWAP_LIBDIR}/find-ifaces" g; "${PWAP_LIBDIR}/find-ifaces" g; } | sort | uniq -u | head -n4)
    ifaces_g=$({ "${PWAP_LIBDIR}/find-ifaces" a; "${PWAP_LIBDIR}/find-ifaces" a; "${PWAP_LIBDIR}/find-ifaces" g; } | sort | uniq -u | head -n3)
    ifaces_ag=$({ "${PWAP_LIBDIR}/find-ifaces" a; "${PWAP_LIBDIR}/find-ifaces" g; } | sort | uniq -d | head -n7)

    ## Add radios which support only 5GHz frequency...
    i=0
    for iface in ${ifaces_a}; do
        channel=${channels_a[i]}
        PWAP_RADIOS+=("${channel}:${iface}")
        used_channels[$channel]=1
        ((++i))
    done

    ## ...then radios supporting only 2.4GHz frequency...
    i=0
    for iface in ${ifaces_g}; do
        channel=${channels_g[i]}
        PWAP_RADIOS+=("${channel}:${iface}")
        used_channels[$channel]=1
        ((++i))
    done

    ## ..and then radios which support both frequencies.
    for iface in ${ifaces_ag}; do

        ## Ensure there is at least one 2.4GHz radio.
        if [ ${#PWAP_RADIOS[@]} -eq 0 ]; then
            channel=${channels_g[0]}
            PWAP_RADIOS+=("${channel}:${iface}")
            used_channels[$channel]=1
            continue
        fi

        ## Pick the best free channel.
        for channel in ${channels[@]}; do
            if [ ${used_channels[$channel]} -eq 0 ]; then
                PWAP_RADIOS+=("${channel}:${iface}")
                used_channels[$channel]=1
                break
            fi
        done
    done
    if [ ${#PWAP_RADIOS[@]} -eq 0 ]; then
        echo "No suitable radios found" >&2
        return 1
    fi
}

start_services()
{
    local net ssid radio iface session bridge

    ## Start one vtund client per network.
    for net in "${PWAP_NETS[@]}"; do
        IFS=':' read _ ssid _ <<<"${net}"

        if [ ${PWAP_LEGACY_MODE} -eq 0 ]; then
            session="${ssid}"
        else
            session="puavo-wlanap"
        fi

        ## Setup the bridge.
        bridge=$("${PWAP_LIBDIR}/get-bridge" "${ssid}")
        brctl addbr "${bridge}"
        brctl setfd "${bridge}" 0
        ifconfig "${bridge}" up
        dhclient -d "${bridge}" &
        echo $! >>"${PWAP_RUNDIR}/critical_service.pids"

        vtund -n -f "${PWAP_RUNDIR}/${ssid}_vtund.conf" \
            -P "${PWAP_GWPORT_DATA}" \
            "${session}" "${PWAP_GWADDR}" &
        echo $! >>"${PWAP_RUNDIR}/critical_service.pids"
    done

    ## Magical sleep to "ensure" that bridges and tunnels are all set
    ## before proceeding.
    sleep 8 & wait $!

    ## Start one hostapd per radio.
    for radio in "${PWAP_RADIOS[@]}"; do
        IFS=':' read _ iface <<<"${radio}"

        ## Try to disable power saving, because it seems to cause flaky
        ## connection quality in some scenarios. However, if something
        ## goes wrong, just log it and keep going; disabled power save
        ## is not a strict requirement.
        iw dev "${iface}" set power_save off || {
            echo "failed to disable power saving" >&2
        }

        hostapd -P "${PWAP_RUNDIR}/${iface}_hostapd.pid" \
            "${PWAP_RUNDIR}/${iface}_hostapd.conf" &
        echo $! >>"${PWAP_RUNDIR}/critical_service.pids"
    done
}

parse_args()
{
    PWAP_ARGS_DAEMON=0

    if [ $# -eq 1 ]; then
        if [ "$1" = "--daemon" ]; then
            PWAP_ARGS_DAEMON=1
            return 0
        fi
        pwap_log "unexpected argument '$1'"
        echo "Usage: $(basename $0) [--daemon]" >&2
        return 1
    elif [ $# -gt 2 ]; then
        pwap_log "too many arguments"
        echo "Usage: $(basename $0) [--daemon]" >&2
        return 1
    fi
}

report_status()
{
    local -r output=$(hostapd_cli -p "${PWAP_RUNDIR}/hostapd" all_sta)
    local -r devices=$(echo -n "${output}" | sed -n 's/^dot11RSNAStatsSTAAddress=//p' | tr '\n' ',')

    pwap_report <<EOF
wlan_event:hotspot_state
connected_devices:[${devices}]
EOF
}

read_config()
{
    . "${PWAP_DATADIR}/config"

    ## The user might have deleted the configuration file, that's ok.
    [ -r "${PWAP_CONFDIR}/config" ] && . "${PWAP_CONFDIR}/config"
}

## We don't know yet where our data, libs and configs have been
## installed, but we do know that the following script knows it and we do
## know where the following script is (its in PATH!).
. puavo-wlanap-env

## Import library routines.
. "${PWAP_LIBDIR}/common.sh"

read_config

parse_args "$@"

if [ "${PWAP_ARGS_DAEMON}" -ne 0 ]; then
    daemon --noconfig --stderr='daemon.info' --name='puavo-wlanap' -- puavo-wlanap
    exit 0
fi

## After this point the process is getting hot and starts taking actions
## which might have persistent side-effects (files, directories,
## bridges, other processes, etc.). The trap is set to ensure that
## everything gets cleaned up properly afterwards.
trap on_exit EXIT

mkdir -p "${PWAP_RUNDIR}"

setup_radios
setup_nets
write_hostapd_conf
write_vtund_conf

trap on_sigchld SIGCHLD
start_services

## Serve forever.
while true; do
    sleep 3 & wait $!

    ## Keep going even if reporting fails.
    report_status || true
done
