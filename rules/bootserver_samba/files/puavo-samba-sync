#!/usr/bin/perl

use strict;
use warnings;

use BerkeleyDB;
use File::Basename;
use File::Slurper qw(read_text);
use IPC::Run qw(run);
use Net::LDAP;
use Net::LDAP::Control::SyncRequest;
use Net::LDAP::Constant qw(LDAP_SYNC_REFRESH_ONLY
                           LDAP_SYNC_REFRESH_AND_PERSIST
                           LDAP_SUCCESS);
use Net::LDAP::LDIF;
use Net::LDAP::Util qw(escape_dn_value escape_filter_value);
use Sys::Syslog qw(:standard :macros);

openlog(basename($0), '', 'user');

my $samba_ad_dc_dir = '/var/lib/samba-ad-dc';
my $samba_sam_ldb_path = "${samba_ad_dc_dir}/private/sam.ldb";
my $puavo_dnmap_path = "${samba_ad_dc_dir}/.puavo_dnmap.db";
my $puavodn_db
  = tie my %puavodn_to_samba_sid, 'BerkeleyDB::Hash',
           -Filename => $puavo_dnmap_path,
           -Flags => DB_CREATE,
           -Mode => 0600
      or die "could not open ${puavo_dnmap_path}";

my %puavo_accounts_seen;

sub handle_search_event {
  my ($msg, $entry) = @_;

  return unless $entry;

  if ($entry->isa('Net::LDAP::Intermediate::SyncInfo')) {
     my $refresh_done = $entry->{asn} && $entry->{asn}{refreshDelete}
                          && $entry->{asn}{refreshDelete}{refreshDone};
     if ($refresh_done) {
       syslog(LOG_NOTICE, 'ldap refresh done, cleaning up Samba user accounts');
       cleanup_removed_users_from_samba();
     }
  }

  if ($entry->isa('Net::LDAP::Entry')) {
    handle_entry($entry);
  }
}

sub cleanup_removed_users_from_samba {
  unless (%puavo_accounts_seen) {
    # this is a safeguard to prevent accidents in case something is badly wrong
    syslog(LOG_NOTICE, 'did not find any Puavo user account,'
                         . ' not removing all Samba accounts');
    return;
  }

  while (my ($puavo_dn, $sid) = each %puavodn_to_samba_sid) {
    next if $puavo_accounts_seen{ $puavo_dn };
    syslog(LOG_INFO,
           'user %s (%s) has disappeared from Puavo, removing from Samba',
           $puavo_dn, $sid);
    remove_account($puavo_dn);
  }
}

sub get_samba_account_info_by_uid {
  my ($uid) = @_;

  my $status = run([ 'pdbedit', '-s', '/etc/samba/samba-ad-dc.conf',
                                '-u', $uid, '-vw' ],
                        \(my $in = ''), \my $user_info, \my $err);
  if (!$status) {
    return undef if $err =~ /Username not found/;
    die "unexpected error looking up user with ${uid}: ${err}";
  }

  my ($flags, $full_name, $nt_hash, $sid, $uid_in_samba);
  foreach (split(/\n/, $user_info)) {
    $flags        = $1     if /^Account Flags\s*:\s*\[(.*)\]$/;
    $full_name    = $1     if /^Full Name\s*:\s*(.*)$/;
    $nt_hash      = lc($1) if /^NT hash\s*:\s*(.*)$/;
    $sid          = $1     if /^User SID\s*:\s*(.*)$/;
  }

  die "user account flags not found for ${uid}" unless defined($flags);
  die "user account full name not found for ${uid}" unless defined($full_name);
  die "user account NT password not found for ${uid}" unless defined($nt_hash);

  {
    flags     => $flags,
    full_name => $full_name,
    nt_hash   => $nt_hash,
    sid       => $sid,
    uid       => $uid,
  };
}

sub create_user {
  my ($puavo_account_info) = @_;

  my $uid = $puavo_account_info->{uid};

  syslog(LOG_INFO, 'creating a new user %s', $uid);

  my @alnums = ('a'..'z','A'..'Z',0..9);
  my $fake_pw = join('', map { $alnums[rand @alnums] } (1..32));
  my $in = "${fake_pw}\n${fake_pw}\n";
  my $err = '';
  run([ 'pdbedit', '-s', '/etc/samba/samba-ad-dc.conf', '-a', '-u', $uid ],
      \$in, \my $out, \$err)
    or die "could not create user: $err";
}

sub get_samba_account_info_by_sid {
  my ($sid) = @_;

  my $search_sid_filter = sprintf('(objectSid=%s)', escape_filter_value($sid));

  my @cmd = ('ldbsearch', '-H', $samba_sam_ldb_path,
               $search_sid_filter, 'sAMAccountName');

  open(my $ldif_cmd, '-|', @cmd)
    or die "could not run ldbsearch looking for $sid";

  my $ldif = Net::LDAP::LDIF->new($ldif_cmd, 'r', onerror => 'undef');

  while (!$ldif->eof()) {
    my $entry = $ldif->read_entry();
    next unless $entry;
    close($ldif_cmd);
    return {
      dn  => $entry->dn,
      uid => $entry->get_value('sAMAccountName'),
    };
  }

  close($ldif_cmd);
  return undef;
}

sub check_and_maybe_update_uid {
  my ($puavo_account_info) = @_;

  my $puavo_dn = $puavo_account_info->{dn};
  my $uid = $puavo_account_info->{uid};
  my $sid = $puavodn_to_samba_sid{$puavo_dn};

  return unless $sid;

  my $samba_account_info = get_samba_account_info_by_sid($sid);

  if (!$samba_account_info) {
    syslog(LOG_WARNING,
           'could not find Samba SID %s for %s, removing from puavo_dnmap',
           $sid, $uid);
    delete $puavodn_to_samba_sid{$puavo_dn};
    $puavodn_db->db_sync();
  }

  my $uid_in_samba = $samba_account_info->{uid};

  if ($uid eq $uid_in_samba) {
    return;
  }

  syslog(LOG_INFO,
         'user id in Puavo has changed from "%s" to "%s", updating id',
         $uid_in_samba, $uid);

  my $current_dn = $samba_account_info->{dn};
  if ($current_dn !~ /^CN=(.*?),(.*)$/) {
    die "Samba user DN ${current_dn} is not in expected format";
  }
  my $expected_dn = sprintf('CN=%s,%s', escape_dn_value($uid), $2);

  if ($current_dn ne $expected_dn) {
    run([ 'ldbrename', '-H', $samba_sam_ldb_path, $current_dn, $expected_dn ],
        '<', '/dev/null', '>&', '/dev/null')
      or die "could not update user ${uid} information";
  }

  my $change_entry = Net::LDAP::Entry->new;
  $change_entry->dn($expected_dn);
  $change_entry->add(changetype     => 'modify');
  $change_entry->add(replace        => 'sAMAccountName');
  $change_entry->add(sAMAccountName => $uid);

  run([ 'ldbmodify', '-H', $samba_sam_ldb_path ],
      \$change_entry->ldif(), '>&', '/dev/null')
    or die "failed to change sAMAccountName for user ${uid}";
}

sub update_puavo_dn_map {
  my ($puavo_account_info, $samba_account_info) = @_;

  my $puavo_dn = $puavo_account_info->{dn};
  my $sid = $samba_account_info->{sid};

  if (!$puavodn_to_samba_sid{$puavo_dn}) {
    $puavodn_to_samba_sid{$puavo_dn} = $sid;
    $puavodn_db->db_sync();
    return;
  }

  if ($puavodn_to_samba_sid{$puavo_dn} ne $sid) {
    my $uid = $puavo_account_info->{uid};
    die "user $uid puavo account ($puavo_dn) maps to a new Samba SID $sid,"
        . " this should never happen";
  }
}

sub update_user_information {
  my ($puavo_account_info, $samba_account_info) = @_;

  my $puavo_dn = $puavo_account_info->{dn};
  my $uid = $puavo_account_info->{uid};

  my @change_opts;

  if ($puavo_account_info->{full_name} ne $samba_account_info->{full_name}) {
    syslog(LOG_INFO, 'update full name for %s', $puavo_account_info->{uid});
    push @change_opts, '--fullname', $puavo_account_info->{full_name};
  }

  if ($puavo_account_info->{nt_hash} ne $samba_account_info->{nt_hash}) {
    syslog(LOG_INFO, 'updating user password for %s',
                     $puavo_account_info->{uid});
    push @change_opts, '--set-nt-hash', $puavo_account_info->{nt_hash};
  }

  if ($puavo_account_info->{locked}
        && index($samba_account_info->{flags}, 'D') == -1) {
    syslog(LOG_INFO, 'disabling user account %s', $puavo_account_info->{uid});
    push @change_opts, '-c', '[D]';
  } elsif (!$puavo_account_info->{locked}
              && index($samba_account_info->{flags}, 'D') >= 0) {
    syslog(LOG_INFO, 'enabling user account %s', $puavo_account_info->{uid});
    push @change_opts, '-c', '[]';
  }

  return unless @change_opts;

  my $in  = '';
  my $err = '';
  run([ 'pdbedit', '-r', '-s', '/etc/samba/samba-ad-dc.conf', '-u', $uid,
        @change_opts ],
      \$in, \my $out, \$err)
    or die "could not update user ${uid} information: ${err}";
}

sub remove_account {
  my ($puavo_dn) = @_;

  eval {
    syslog(LOG_INFO, 'deleting user %s from Samba', $puavo_dn);

    my $sid = $puavodn_to_samba_sid{$puavo_dn};
    unless ($sid) {
      die('could not find user SambaSID for Puavo account '
            . $puavo_dn . ' that should be removed');
    }

    my $samba_account_info = get_samba_account_info_by_sid($sid);
    if ($samba_account_info) {
      run([ 'pdbedit', '-s', '/etc/samba/samba-ad-dc.conf',
                       '-x', '-u', $samba_account_info->{uid} ],
              '<', '/dev/null', '>&', '/dev/null')
        or die "could not remove ${puavo_dn} (SambaSID ${sid}) from Samba";
    } else {
      syslog(LOG_WARNING,
             'could not lookup samba account information for Samba SID %s,'
               . ' presuming it no longer exists',
             $sid);
    }

    delete $puavodn_to_samba_sid{$puavo_dn};
    $puavodn_db->db_sync();

    syslog(LOG_WARNING, 'user %s was deleted from Samba with success',
                        $puavo_dn);
  };
  if ($@) {
    chomp $@;
    syslog(LOG_ERR, 'error in removing user account: %s', $@);
  }
}

sub handle_entry {
  my ($entry) = @_;

  if (!$entry->attributes) {
    remove_account($entry->dn);
    return;
  }

  eval {
    my $dn  = $entry->dn;
    my $uid = $entry->get_value('uid');

    $puavo_accounts_seen{ $dn } = 1;

    foreach (qw(givenName puavoLocked sambaNTPassword sn uid)) {
      unless ($entry->exists($_)) {
        syslog(LOG_WARNING, "user %s does not have '%s' attribute",
                            $uid || $dn, $_);
        return;
      }
    }

    my $puavo_account_info = {
      dn        => $dn,
      full_name => $entry->get_value('givenName')
                     . ' ' . $entry->get_value('sn'),
      locked    => ($entry->get_value('puavoLocked') eq 'TRUE'),
      nt_hash   => $entry->get_value('sambaNTPassword'),
      uid       => $uid,
    };

    check_and_maybe_update_uid($puavo_account_info);

    my $samba_account_info = get_samba_account_info_by_uid($uid);

    unless (defined($samba_account_info)) {
      create_user($puavo_account_info);
      $samba_account_info = get_samba_account_info_by_uid($uid);
      die("could not get user account info for ${uid}"
            . ' (even though it was just created)')
        unless defined($samba_account_info);
    }

    update_puavo_dn_map($puavo_account_info, $samba_account_info);

    update_user_information($puavo_account_info, $samba_account_info);
  };
  if ($@) {
    chomp $@;
    syslog(LOG_ERR, 'error in updating user information: %s', $@);
  }
}

chomp(my $bind_dn     = read_text('/etc/puavo/ldap/dn'));
chomp(my $bind_pw     = read_text('/etc/puavo/ldap/password'));
chomp(my $ldap_base   = read_text('/etc/puavo/ldap/base'));
chomp(my $my_hostname = read_text('/etc/puavo/hostname'));
chomp(my $my_domain   = read_text('/etc/puavo/domain'));
my $ldap_host = "${my_hostname}.${my_domain}";

my $ldap = Net::LDAP->new($ldap_host);
unless ($ldap) {
  syslog(LOG_ERR, 'no ldap server %s', $ldap_host);
  exit(1);
}

# XXX should really use verify
my $ldap_response;
$ldap_response = $ldap->start_tls(verify => 'none');
if ($ldap_response->code != LDAP_SUCCESS) {
  syslog(LOG_ERR, 'could not start_tls on %s', $ldap_host);
  exit(1);
}

$ldap_response = $ldap->bind($bind_dn, password => $bind_pw);
if ($ldap_response->code != LDAP_SUCCESS) {
  syslog(LOG_ERR, 'failed to authenticate to %s', $ldap_host);
  exit(1);
}

my $req = Net::LDAP::Control::SyncRequest->new(
            mode => LDAP_SYNC_REFRESH_AND_PERSIST);

# XXX how to prevent multiple instances of this script running?
# XXX should there be some kind of a lock?

my @followed_attributes = qw(givenName puavoLocked sambaNTPassword sn uid);

my $search = $ldap->search(base     => "ou=People,${ldap_base}",
                           scope    => 'sub',
                           control  => [ $req ],
                           callback => \&handle_search_event,
                           filter   => '(objectClass=sambaSamAccount)',
                           attrs    => \@followed_attributes);

# XXX should never get here, what to do if we do?
# XXX is $search useful ?
