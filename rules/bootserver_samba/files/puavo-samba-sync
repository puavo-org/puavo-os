#!/usr/bin/perl

use strict;
use warnings;

use BerkeleyDB;
use File::Basename;
use File::Slurper qw(read_text);
use IPC::Run qw(run);
use Net::LDAP;
use Net::LDAP::Control::SyncRequest;
use Net::LDAP::Constant qw(LDAP_SYNC_REFRESH_ONLY
                           LDAP_SYNC_REFRESH_AND_PERSIST
                           LDAP_SUCCESS);
use Net::LDAP::LDIF;
use Net::LDAP::Util qw(escape_dn_value escape_filter_value);
use Sys::Syslog qw(:standard :macros);

openlog(basename($0), '', 'user');

my $samba_ad_dc_dir = '/var/lib/samba-ad-dc';
my $samba_sam_ldb_path = "${samba_ad_dc_dir}/private/sam.ldb";
my $puavo_idmap_path = "${samba_ad_dc_dir}/.puavo_idmap.db";
my $puavoid_db
  = tie my %puavoid_to_samba_sid, 'BerkeleyDB::Hash',
           -Filename => $puavo_idmap_path,
           -Flags => DB_CREATE,
           -Mode => 0600
      or die "could not open ${puavo_idmap_path}";

chomp(my $bind_dn   = read_text('/etc/puavo/ldap/dn'));
chomp(my $bind_pw   = read_text('/etc/puavo/ldap/password'));
chomp(my $ldap_base = read_text('/etc/puavo/ldap/base'));
chomp(my $ldap_host = read_text('/etc/puavo/ldap/master'));

my $ldap = Net::LDAP->new($ldap_host);
unless ($ldap) {
  syslog(LOG_ERR, 'no ldap server %s', $ldap_host);
  exit(1);
}

# XXX should really use verify
my $ldap_response;
$ldap_response = $ldap->start_tls(verify => 'none');
if ($ldap_response->code != LDAP_SUCCESS) {
  syslog(LOG_ERR, 'could not start_tls on %s', $ldap_host);
  exit(1);
}

$ldap_response = $ldap->bind($bind_dn, password => $bind_pw);
if ($ldap_response->code != LDAP_SUCCESS) {
  syslog(LOG_ERR, 'failed to authenticate to %s', $ldap_host);
  exit(1);
}

my $req = Net::LDAP::Control::SyncRequest->new(
            mode => LDAP_SYNC_REFRESH_AND_PERSIST);

# XXX how to prevent multiple instances of this script running?
# XXX should there be some kind of a lock?

my @followed_attributes
  = qw(givenName puavoId puavoLocked sambaNTPassword sn uid);

my $search = $ldap->search(base     => "ou=People,${ldap_base}",
                           scope    => 'sub',
                           control  => [ $req ],
                           callback => \&handle_search_event,
                           filter   => '(objectClass=sambaSamAccount)',
                           attrs    => \@followed_attributes);

# XXX should never get here, what to do if we do?
# XXX is $search useful ?

sub handle_search_event {
  my ($msg, $entry) = @_;

  return unless $entry;

  if ($entry->isa('Net::LDAP::Entry')) {
    handle_entry($entry);
  }
}

# XXX how to remove users that have been removed from Puavo
# XXX how to lock users that have been locked in Puavo?

sub get_samba_account_info_by_uid {
  my ($uid) = @_;

  my $status = run([ 'pdbedit', '-s', '/etc/samba/samba-ad-dc.conf',
                                '-u', $uid, '-vw' ],
                        \(my $in = ''), \my $user_info, \my $err);
  if (!$status) {
    return undef if $err =~ /Username not found/;
    die "unexpected error looking up user with ${uid}: ${err}";
  }

  my ($flags, $full_name, $nt_hash, $sid, $uid_in_samba);
  foreach (split(/\n/, $user_info)) {
    $flags        = $1     if /^Account Flags\s*:\s*\[(.*)\]$/;
    $full_name    = $1     if /^Full Name\s*:\s*(.*)$/;
    $nt_hash      = lc($1) if /^NT hash\s*:\s*(.*)$/;
    $sid          = $1     if /^User SID\s*:\s*(.*)$/;
  }

  die "user account flags not found for ${uid}" unless defined($flags);
  die "user account full name not found for ${uid}" unless defined($full_name);
  die "user account NT password not found for ${uid}" unless defined($nt_hash);

  {
    flags     => $flags,
    full_name => $full_name,
    nt_hash   => $nt_hash,
    sid       => $sid,
    uid       => $uid,
  };
}

sub create_user {
  my ($puavo_account_info) = @_;

  my $uid = $puavo_account_info->{uid};

  syslog(LOG_INFO, 'creating a new user %s', $uid);

  my @alnums = ('a'..'z','A'..'Z',0..9);
  my $fake_pw = join('', map { $alnums[rand @alnums] } (1..32));
  my $in = "${fake_pw}\n${fake_pw}\n";
  my $err = '';
  run([ 'pdbedit', '-s', '/etc/samba/samba-ad-dc.conf', '-a', '-u', $uid ],
      \$in, \my $out, \$err)
    or die "could not create user: $err";
}

sub get_samba_account_info_by_sid {
  my ($sid) = @_;

  my $search_sid_filter = sprintf('(objectSid=%s)', escape_filter_value($sid));

  my @cmd = ('ldbsearch', '-H', $samba_sam_ldb_path,
               $search_sid_filter, 'sAMAccountName');

  open(my $ldif_cmd, '-|', @cmd)
    or die "could not run ldbsearch looking for $sid";

  my $ldif = Net::LDAP::LDIF->new($ldif_cmd, 'r', onerror => 'undef');

  while (!$ldif->eof()) {
    my $entry = $ldif->read_entry();
    next unless $entry;
    close($ldif_cmd);
    return {
      dn  => $entry->dn,
      uid => $entry->get_value('sAMAccountName'),
    };
  }

  close($ldif_cmd);
  return undef;
}

sub check_and_maybe_update_uid {
  my ($puavo_account_info) = @_;

  my $puavo_id = $puavo_account_info->{puavo_id};
  my $uid = $puavo_account_info->{uid};
  my $sid = $puavoid_to_samba_sid{$puavo_id};

  return unless $sid;

  my $samba_account_info = get_samba_account_info_by_sid($sid);

  if (!$samba_account_info) {
    syslog(LOG_WARNING,
           'could not find Samba SID %s for %s, removing from puavo_idmap',
           $sid, $uid);
    delete $puavoid_to_samba_sid{$puavo_id};
    $puavoid_db->db_sync();
  }

  my $uid_in_samba = $samba_account_info->{uid};

  if ($uid eq $uid_in_samba) {
    return;
  }

  syslog(LOG_INFO,
         'user id in Puavo has changed from "%s" to "%s", updating id',
         $uid_in_samba, $uid);

  my $current_dn = $samba_account_info->{dn};
  if ($current_dn !~ /^CN=(.*?),(.*)$/) {
    die "Samba user DN ${current_dn} is not in expected format";
  }
  my $expected_dn = sprintf('CN=%s,%s', escape_dn_value($uid), $2);

  if ($current_dn ne $expected_dn) {
    run([ 'ldbrename', '-H', $samba_sam_ldb_path, $current_dn, $expected_dn ],
        '<', '/dev/null', '>&', '/dev/null')
      or die "could not update user ${uid} information";
  }

  my $change_entry = Net::LDAP::Entry->new;
  $change_entry->dn($expected_dn);
  $change_entry->add(changetype     => 'modify');
  $change_entry->add(replace        => 'sAMAccountName');
  $change_entry->add(sAMAccountName => $uid);

  run([ 'ldbmodify', '-H', $samba_sam_ldb_path ],
      \$change_entry->ldif(), '>&', '/dev/null')
    or die "failed to change sAMAccountName for user ${uid}";
}

sub update_puavo_id_map {
  my ($puavo_account_info, $samba_account_info) = @_;

  my $puavo_id = $puavo_account_info->{puavo_id};
  my $sid = $samba_account_info->{sid};

  if (!$puavoid_to_samba_sid{$puavo_id}) {
    $puavoid_to_samba_sid{$puavo_id} = $sid;
    $puavoid_db->db_sync();
    return;
  }

  if ($puavoid_to_samba_sid{$puavo_id} ne $sid) {
    my $uid = $puavo_account_info->{uid};
    die "user $uid puavoId ($puavo_id) maps to a new Samba SID $sid,"
        . " this should never happen";
  }
}

sub update_user_information {
  my ($puavo_account_info, $samba_account_info) = @_;

  my $puavo_id = $puavo_account_info->{puavo_id};
  my $uid = $puavo_account_info->{uid};

  my @change_opts;

  if ($puavo_account_info->{full_name} ne $samba_account_info->{full_name}) {
    syslog(LOG_INFO, 'update full name for %s', $puavo_account_info->{uid});
    push @change_opts, '--fullname', $puavo_account_info->{full_name};
  }

  if ($puavo_account_info->{nt_hash} ne $samba_account_info->{nt_hash}) {
    syslog(LOG_INFO, 'updating user password for %s',
                     $puavo_account_info->{uid});
    push @change_opts, '--set-nt-hash', $puavo_account_info->{nt_hash};
  }

  return unless @change_opts;

  my $in  = '';
  my $err = '';
  run([ 'pdbedit', '-r', '-s', '/etc/samba/samba-ad-dc.conf', '-u', $uid,
        @change_opts ],
      \$in, \my $out, \$err)
    or die "could not update user ${uid} information: ${err}";
}

sub handle_entry {
  my ($entry) = @_;

  # XXX we are also interested in the puavoLocked attribute
  # XXX what kind of event we get when an account is REMOVED from Puavo?

  foreach (qw(givenName puavoId sambaNTPassword sn uid)) {
    unless ($entry->exists($_)) {
      syslog(LOG_WARNING, "got an entry without '%s' attribute", $_);
      return;
    }
  }

  my $uid = $entry->get_value('uid');

  my $puavo_account_info = {
    full_name => $entry->get_value('givenName')
                    . ' ' . $entry->get_value('sn'),
    locked    => $entry->get_value('puavoLocked'),
    nt_hash   => $entry->get_value('sambaNTPassword'),
    puavo_id  => $entry->get_value('puavoId'),
    uid       => $uid,
  };

  eval {
    check_and_maybe_update_uid($puavo_account_info);

    my $samba_account_info = get_samba_account_info_by_uid($uid);

    unless (defined($samba_account_info)) {
      create_user($puavo_account_info);
      $samba_account_info = get_samba_account_info_by_uid($uid);
      die("could not get user account info for ${uid}"
            . ' (even though it was just created)')
        unless defined($samba_account_info);
    }

    update_puavo_id_map($puavo_account_info, $samba_account_info);

    update_user_information($puavo_account_info, $samba_account_info);
  };
  if ($@) {
    chomp $@;
    syslog(LOG_ERR, 'error in updating user information: %s', $@);
  }
}
